{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TelSIM GUI Documentation Author: Preston Ito Date: 14 July 2022 Code/.ui file directory The two components needed for this project are the python file and the .ui file. The .ui file is essentialy the layout of the GUI, and is created in Qt Designer. Both files can be found at: /usr/local/home/pito/kroot/src/kss/ao/tsim/TelSimGUI The final python file is called 1SMGUI.py and the final .ui file is called dummy.ui One can add/remove widgets to the .ui file and reconfigure them accordingly. Breaking the layout is necessary to reformatting the widgets. Note: It is reccommended to make a copy of the .ui file and edit that newly created version to keep the working .ui file untouched, because Qt Designer can be finicky and difficult to work with. Imports and KPython Address These are all the imports necessary for the code. It also has KPython address and sets up EPICS channels for translation stage simulators. A good chunk of this code comes from another GUI project created by Paul Richards. His source code was used as a template for this GUI. #! @KPYTHON3@ # # kpython safely sets RELDIR, KROOT, LROOT, and PYTHONPATH before invoking # the actual Python interpreter. # Setup an EPICS address list if one is not already defined import os import subprocess import datetime import time addrs = 'localhost:5064 vm-k1epicsgateway:5064 vm-k2epicsgateway:5064 k1aoserver-new:8607 localhost:5555' print(f'Overriding EPICS address list to: {addrs}') os.environ['EPICS_CA_ADDR_LIST'] = addrs os.environ['EPICS_CA_AUTO_ADDR_LIST'] = 'NO' # Keck library includes import ktl # provided by kroot/ktl/keyword/python import kPyQt # provided by kroot/kui/kPyQt import logging, coloredlogs import argparse import sys import datetime import base64 from dateutil.parser import isoparse import requests import io from enum import Enum, auto import urllib import functools from PyQt5 import QtCore, QtWidgets, uic from PyQt5.QtWidgets import QStatusBar, QMessageBox, QWidget, QVBoxLayout, QLabel, QPushButton, \\ QToolButton, QSpacerItem, QSizePolicy, QFileDialog, QShortcut, QLCDNumber, QLayout from PyQt5.QtCore import Qt, QSize, QTimer from PyQt5.QtGui import QFont, QIcon, QPixmap, QImage, QIntValidator, QDoubleValidator, QKeySequence from PyQt5.Qt import QApplication from PToggle import PToggle, PAnimatedToggle from datetime import datetime Constants, showDialog function, and state machine class These are all of the constants used throughout the code. A showDialog function is included to be called whenever QMessageBoxes are used. The code was structured using state machines. debug = False SECONDS = 1 FONTBOLD = 'Montserrat SemiBold' FONTLIGHT = 'Montserrat Light' STATUSBAR_WHITE_STYLE = 'QStatusBar{padding-left:8px;background:white;color:black;font-weight:bold;}' STATUSBAR_YELLOW_STYLE = 'QStatusBar{padding-left:8px;background:yellow;color:black;font-weight:bold;}' EDIT_STYLE = 'font: 25 14pt \"Montserrat SemiBold\";' MODE_CLEAR_STYLE = 'background-color: rgb(255, 255, 255);' MODE_SET_STYLE = 'background-color: rgb(0, 170, 0);' MODE_UNSET_STYLE = 'background-color: rgb(170, 170, 170);' STATUS_RED_STYLE = 'background-color: rgb(255, 0, 0);' STATUS_GREEN_STYLE = 'background-color: rgb(0, 255, 0);' MESSAGE_LIMIT = 100 class TelSimStates(Enum): OFF = 0 ON = auto() IDLE = auto() MOVE_ALT = auto() AWAIT_ALT = auto() MOVE_WIND = auto() AWAIT_WIND = auto() STOPPED = auto() CLEANUP = auto() def showDialog(text, yes=False, cancel=False): ''' Show a message box to the user. :param text: The message to be displayed. :param yes: Use \"Yes/No\" instead of \"OK/Cancel\" :param cancel: Show a Cancel button, versus just OK. :return: Nothing. ''' # Create a message box msgBox = QtWidgets.QMessageBox() msgBox.setIcon(QMessageBox.Information) msgBox.setText(text) msgBox.setWindowTitle('Message') # Add buttons, either OK or OK+Cancel or Yes+No if yes: msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No) elif cancel: msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel) else: msgBox.setStandardButtons(QMessageBox.Ok) # Test the return from the message box returnValue = msgBox.exec() if returnValue in [QMessageBox.Ok, QMessageBox.Yes]: return True else: return False The initializer function def __init__(self, *args, **kwargs): # self.list = None self.popups = {} self.template = None # Make access to data be thread safe with a mutex (chart data, in particular) self._mutex = QtCore.QMutex() QtWidgets.QMainWindow.__init__(self, *args, **kwargs) # Load the UI file uifile = 'dummy.ui' path = '.' filename = os.path.join(path, uifile) if not os.path.exists(filename): filename = os.path.join(os.environ['KROOT'], 'rel/uno/default/data', uifile) uic.loadUi(filename, self) To load a new .ui file, change the line: uifile = '{NEW_FILE.UI}' Setup UI This is where all of the setup occurs; Everything from setting the GUI title to connecting to simulator channels. Display Some display features are edited here. A list of widgets are kept to enable/disable with ease. def setupUI(self, channels=None): title = 'Telescope Simulator GUI' self.setWindowTitle(title) # ----------------------------------------------------------------------------- # Make the menu bar work the same across all platforms (looking at you, MacOS) self.menubar.setNativeMenuBar(False) # Enabling/disabling feature when TelSIM button pressed self.controls = [self.windTSBox, self.TSBox, self.altGroupBox, self.wavefrontGroupBox, self.fileGroupBox, self.loopocBox, self.loopControlLabel] Timers The countdownTimer (the timer used for the display countdown while Wind TS is moving) is created here. 'Setting single shot' ensures that the timer only runs once and doesn't keep repeating once it finishes counting down. # Timers self.countdownTimer = QTimer() # Display timer self.countdownTimer.setSingleShot(True) self.LCDnumbers.display(\"0.00\") self.secondsToMove = 0 Actions Connects buttons/text fields/radio buttons to their respective functions. For the input boxes, set a boolean attribute to ensure background color change only when user is editing (and not when it gets signals from the channel). # Actions! Connects buttons/text fields to functions self.selectFileButton.clicked.connect(self.fileSelection) self.reconstructorButton.clicked.connect(self.reconstructorSelection) self.gainInput.editingFinished.connect(lambda: self.gainCheck(self.gainInput.text())) self.frameRateInput.editingFinished.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) self.bin.toggled.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) self.unbin.toggled.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) # Creates 'changed' attributes for the background color feature while editing setattr(self.posBox, 'changed', False) self.posBox.editingFinished.connect(lambda: self.posCheck(self.posBox.text())) self.posBox.textChanged.connect(lambda: self.editTextChanged(self.posBox)) setattr(self.velBox, 'changed', False) self.velBox.editingFinished.connect(lambda: self.velCheck(self.velBox.text())) self.velBox.textChanged.connect(lambda: self.editTextChanged(self.velBox)) setattr(self.accelBox, 'changed', False) self.accelBox.editingFinished.connect(lambda: self.accelCheck(self.accelBox.text())) self.accelBox.textChanged.connect(lambda: self.editTextChanged(self.accelBox)) setattr(self.altBox, 'changed', False) self.altBox.editingFinished.connect(lambda: self.altCheck(self.altBox.text())) self.altBox.textChanged.connect(lambda: self.editTextChanged(self.altBox)) Channels Connects to the different channels. The different types are RBV (read back value), VAL (position value), VELO (velocity), ACCL (acceleration), MOVN (returns moving status), SPMG (returns one of these values: Stop, Pause, Move, Go). Note: Writing a position value must be done to the .VAL, while reading back it's position is done through .RBV. # Channel creation for the emulator self.posChan = kPyQt.caFactory(\"wndsim:ln:m1.RBV\", kPyQt.Channel.caFloat) self.posWritingChan = kPyQt.caFactory(\"wndsim:ln:m1.VAL\", kPyQt.Channel.caFloat) self.velChan = kPyQt.caFactory(\"wndsim:ln:m1.VELO\", kPyQt.Channel.caFloat) self.accelChan = kPyQt.caFactory(\"wndsim:ln:m1.ACCL\", kPyQt.Channel.caFloat) self.altChan = kPyQt.caFactory(\"wndsim:ln:m2.RBV\", kPyQt.Channel.caFloat) self.altWritingChan = kPyQt.caFactory(\"wndsim:ln:m2.VAL\", kPyQt.Channel.caFloat) self.altMovingChan = kPyQt.caFactory(\"wndsim:ln:m2.MOVN\", kPyQt.Channel.caFloat) self.windStopChan = kPyQt.caFactory(\"wndsim:ln:m1.SPMG\", kPyQt.Channel.caFloat) self.altStopChan = kPyQt.caFactory(\"wndsim:ln:m2.SPMG\", kPyQt.Channel.caFloat)","title":"Home"},{"location":"#telsim-gui-documentation","text":"Author: Preston Ito Date: 14 July 2022","title":"TelSIM GUI Documentation"},{"location":"#codeui-file-directory","text":"The two components needed for this project are the python file and the .ui file. The .ui file is essentialy the layout of the GUI, and is created in Qt Designer. Both files can be found at: /usr/local/home/pito/kroot/src/kss/ao/tsim/TelSimGUI The final python file is called 1SMGUI.py and the final .ui file is called dummy.ui One can add/remove widgets to the .ui file and reconfigure them accordingly. Breaking the layout is necessary to reformatting the widgets. Note: It is reccommended to make a copy of the .ui file and edit that newly created version to keep the working .ui file untouched, because Qt Designer can be finicky and difficult to work with.","title":"Code/.ui file directory"},{"location":"#imports-and-kpython-address","text":"These are all the imports necessary for the code. It also has KPython address and sets up EPICS channels for translation stage simulators. A good chunk of this code comes from another GUI project created by Paul Richards. His source code was used as a template for this GUI. #! @KPYTHON3@ # # kpython safely sets RELDIR, KROOT, LROOT, and PYTHONPATH before invoking # the actual Python interpreter. # Setup an EPICS address list if one is not already defined import os import subprocess import datetime import time addrs = 'localhost:5064 vm-k1epicsgateway:5064 vm-k2epicsgateway:5064 k1aoserver-new:8607 localhost:5555' print(f'Overriding EPICS address list to: {addrs}') os.environ['EPICS_CA_ADDR_LIST'] = addrs os.environ['EPICS_CA_AUTO_ADDR_LIST'] = 'NO' # Keck library includes import ktl # provided by kroot/ktl/keyword/python import kPyQt # provided by kroot/kui/kPyQt import logging, coloredlogs import argparse import sys import datetime import base64 from dateutil.parser import isoparse import requests import io from enum import Enum, auto import urllib import functools from PyQt5 import QtCore, QtWidgets, uic from PyQt5.QtWidgets import QStatusBar, QMessageBox, QWidget, QVBoxLayout, QLabel, QPushButton, \\ QToolButton, QSpacerItem, QSizePolicy, QFileDialog, QShortcut, QLCDNumber, QLayout from PyQt5.QtCore import Qt, QSize, QTimer from PyQt5.QtGui import QFont, QIcon, QPixmap, QImage, QIntValidator, QDoubleValidator, QKeySequence from PyQt5.Qt import QApplication from PToggle import PToggle, PAnimatedToggle from datetime import datetime","title":"Imports and KPython Address"},{"location":"#constants-showdialog-function-and-state-machine-class","text":"These are all of the constants used throughout the code. A showDialog function is included to be called whenever QMessageBoxes are used. The code was structured using state machines. debug = False SECONDS = 1 FONTBOLD = 'Montserrat SemiBold' FONTLIGHT = 'Montserrat Light' STATUSBAR_WHITE_STYLE = 'QStatusBar{padding-left:8px;background:white;color:black;font-weight:bold;}' STATUSBAR_YELLOW_STYLE = 'QStatusBar{padding-left:8px;background:yellow;color:black;font-weight:bold;}' EDIT_STYLE = 'font: 25 14pt \"Montserrat SemiBold\";' MODE_CLEAR_STYLE = 'background-color: rgb(255, 255, 255);' MODE_SET_STYLE = 'background-color: rgb(0, 170, 0);' MODE_UNSET_STYLE = 'background-color: rgb(170, 170, 170);' STATUS_RED_STYLE = 'background-color: rgb(255, 0, 0);' STATUS_GREEN_STYLE = 'background-color: rgb(0, 255, 0);' MESSAGE_LIMIT = 100 class TelSimStates(Enum): OFF = 0 ON = auto() IDLE = auto() MOVE_ALT = auto() AWAIT_ALT = auto() MOVE_WIND = auto() AWAIT_WIND = auto() STOPPED = auto() CLEANUP = auto() def showDialog(text, yes=False, cancel=False): ''' Show a message box to the user. :param text: The message to be displayed. :param yes: Use \"Yes/No\" instead of \"OK/Cancel\" :param cancel: Show a Cancel button, versus just OK. :return: Nothing. ''' # Create a message box msgBox = QtWidgets.QMessageBox() msgBox.setIcon(QMessageBox.Information) msgBox.setText(text) msgBox.setWindowTitle('Message') # Add buttons, either OK or OK+Cancel or Yes+No if yes: msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No) elif cancel: msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel) else: msgBox.setStandardButtons(QMessageBox.Ok) # Test the return from the message box returnValue = msgBox.exec() if returnValue in [QMessageBox.Ok, QMessageBox.Yes]: return True else: return False","title":"Constants, showDialog function, and state machine class"},{"location":"#the-initializer-function","text":"def __init__(self, *args, **kwargs): # self.list = None self.popups = {} self.template = None # Make access to data be thread safe with a mutex (chart data, in particular) self._mutex = QtCore.QMutex() QtWidgets.QMainWindow.__init__(self, *args, **kwargs) # Load the UI file uifile = 'dummy.ui' path = '.' filename = os.path.join(path, uifile) if not os.path.exists(filename): filename = os.path.join(os.environ['KROOT'], 'rel/uno/default/data', uifile) uic.loadUi(filename, self) To load a new .ui file, change the line: uifile = '{NEW_FILE.UI}'","title":"The initializer function"},{"location":"#setup-ui","text":"This is where all of the setup occurs; Everything from setting the GUI title to connecting to simulator channels.","title":"Setup UI"},{"location":"#display","text":"Some display features are edited here. A list of widgets are kept to enable/disable with ease. def setupUI(self, channels=None): title = 'Telescope Simulator GUI' self.setWindowTitle(title) # ----------------------------------------------------------------------------- # Make the menu bar work the same across all platforms (looking at you, MacOS) self.menubar.setNativeMenuBar(False) # Enabling/disabling feature when TelSIM button pressed self.controls = [self.windTSBox, self.TSBox, self.altGroupBox, self.wavefrontGroupBox, self.fileGroupBox, self.loopocBox, self.loopControlLabel]","title":"Display"},{"location":"#timers","text":"The countdownTimer (the timer used for the display countdown while Wind TS is moving) is created here. 'Setting single shot' ensures that the timer only runs once and doesn't keep repeating once it finishes counting down. # Timers self.countdownTimer = QTimer() # Display timer self.countdownTimer.setSingleShot(True) self.LCDnumbers.display(\"0.00\") self.secondsToMove = 0","title":"Timers"},{"location":"#actions","text":"Connects buttons/text fields/radio buttons to their respective functions. For the input boxes, set a boolean attribute to ensure background color change only when user is editing (and not when it gets signals from the channel). # Actions! Connects buttons/text fields to functions self.selectFileButton.clicked.connect(self.fileSelection) self.reconstructorButton.clicked.connect(self.reconstructorSelection) self.gainInput.editingFinished.connect(lambda: self.gainCheck(self.gainInput.text())) self.frameRateInput.editingFinished.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) self.bin.toggled.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) self.unbin.toggled.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) # Creates 'changed' attributes for the background color feature while editing setattr(self.posBox, 'changed', False) self.posBox.editingFinished.connect(lambda: self.posCheck(self.posBox.text())) self.posBox.textChanged.connect(lambda: self.editTextChanged(self.posBox)) setattr(self.velBox, 'changed', False) self.velBox.editingFinished.connect(lambda: self.velCheck(self.velBox.text())) self.velBox.textChanged.connect(lambda: self.editTextChanged(self.velBox)) setattr(self.accelBox, 'changed', False) self.accelBox.editingFinished.connect(lambda: self.accelCheck(self.accelBox.text())) self.accelBox.textChanged.connect(lambda: self.editTextChanged(self.accelBox)) setattr(self.altBox, 'changed', False) self.altBox.editingFinished.connect(lambda: self.altCheck(self.altBox.text())) self.altBox.textChanged.connect(lambda: self.editTextChanged(self.altBox))","title":"Actions"},{"location":"#channels","text":"Connects to the different channels. The different types are RBV (read back value), VAL (position value), VELO (velocity), ACCL (acceleration), MOVN (returns moving status), SPMG (returns one of these values: Stop, Pause, Move, Go). Note: Writing a position value must be done to the .VAL, while reading back it's position is done through .RBV. # Channel creation for the emulator self.posChan = kPyQt.caFactory(\"wndsim:ln:m1.RBV\", kPyQt.Channel.caFloat) self.posWritingChan = kPyQt.caFactory(\"wndsim:ln:m1.VAL\", kPyQt.Channel.caFloat) self.velChan = kPyQt.caFactory(\"wndsim:ln:m1.VELO\", kPyQt.Channel.caFloat) self.accelChan = kPyQt.caFactory(\"wndsim:ln:m1.ACCL\", kPyQt.Channel.caFloat) self.altChan = kPyQt.caFactory(\"wndsim:ln:m2.RBV\", kPyQt.Channel.caFloat) self.altWritingChan = kPyQt.caFactory(\"wndsim:ln:m2.VAL\", kPyQt.Channel.caFloat) self.altMovingChan = kPyQt.caFactory(\"wndsim:ln:m2.MOVN\", kPyQt.Channel.caFloat) self.windStopChan = kPyQt.caFactory(\"wndsim:ln:m1.SPMG\", kPyQt.Channel.caFloat) self.altStopChan = kPyQt.caFactory(\"wndsim:ln:m2.SPMG\", kPyQt.Channel.caFloat)","title":"Channels"},{"location":"about/","text":"About KAPA Telescope Simulator The Keck All-sky Precision Adaptive-optics (KAPA) project will be a next-generation tomographic laser AO system, projected to begin operation at the W.M. Keck Observatory in 2024. To test their AO algorithm, Keck has built a Telescope Simulator that simulates the KAPA system on a smaller scale and more controlled environment. The KAPA Telescope Simulator is being further modified to include a turbulence simulator, which includes a glass phase screen, to simulate typical atmospheric turbulence at various altitudes and wind speeds. This simulator must move extremely precisely in two-dimensions, and will do so via two precision translation stages. GUI The turbulence simulator requires control from a GUI that adjusts different parameters necessary for the AO simulator\u2019s function. This GUI will also control some AO parameters, such as the wavefront sensor\u2019s gain, and frame rate, as well as have the ability to invoke other AO operational GUIs. The ultimate goal of this project was to create an intuitive GUI that could be used by astronomers and engineers alike. Here is a list of blah blah connection gain timer this is a hyperlink example and a bold example .","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#kapa-telescope-simulator","text":"The Keck All-sky Precision Adaptive-optics (KAPA) project will be a next-generation tomographic laser AO system, projected to begin operation at the W.M. Keck Observatory in 2024. To test their AO algorithm, Keck has built a Telescope Simulator that simulates the KAPA system on a smaller scale and more controlled environment. The KAPA Telescope Simulator is being further modified to include a turbulence simulator, which includes a glass phase screen, to simulate typical atmospheric turbulence at various altitudes and wind speeds. This simulator must move extremely precisely in two-dimensions, and will do so via two precision translation stages.","title":"KAPA Telescope Simulator"},{"location":"about/#gui","text":"The turbulence simulator requires control from a GUI that adjusts different parameters necessary for the AO simulator\u2019s function. This GUI will also control some AO parameters, such as the wavefront sensor\u2019s gain, and frame rate, as well as have the ability to invoke other AO operational GUIs. The ultimate goal of this project was to create an intuitive GUI that could be used by astronomers and engineers alike. Here is a list of blah blah connection gain timer this is a hyperlink example and a bold example .","title":"GUI"}]}