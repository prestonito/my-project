{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TelSIM GUI User Manual Author: Preston Ito Last updated: 22 July 2022 Opening GUI !To-do Note: Figure out how to make it executable anywhere. Then change this part. While in the directory /usr/local/home/pito/kroot/src/kss/ao/tsim/TelSimGUI run the following command: kpython3 1SMGUI.py Workflow The user will open the GUI from within their VNC Enable GUI and startup telescope simulator with the 'Setup TelSIM' button The user will change any desired parameters: Wind TS: position, velocity, acceleration Alt TS: position Loop Control: open/closed TS Connections: on/off Binned Mode: bin/unbinned Import File: The user can choose to import a .txt file to auto run different tests Once the user has finished changing everything they want, start running the test with 'Start' button. When the 'Start' button is pressed initially, the timer will change to display the (rough) time it will take for the Wind TS to get to its position, but nothing will start until the user verifies the start from a popup. Once the start is verified, the alt TS will move to its desired position. After it reaches its destination, only then will the wind TS and timer start. Note: The timer doesn't run for the Alt TS, only for the Wind TS. If the test needs to be stopped in the middle of a test, stop all movement with the 'Stop' button To open other GUI's, hit the 'Other GUIs' dropdown in the top menu and select desired GUI. Note: Might need to do ssh-keygen to authenticate account with GUI permissions Once the user is done, hit the 'Close TelSIM' button to disable GUI and \"home\" the positions of the two translation stages States Off When first opening the GUI, it will look like this. All of the editable widgets will be disabled, with the exception of the 'Start TelSIM' button. This button is the only way to enable everything upon startup. Idle After clicking the 'Start TelSIM' button, all of the editable widgets will be enabled and the user can edit parameters as they wish. Also, the 'Start TelSIM' button will turn into a 'Close TelSIM' button that will reset the TS positions and disabled all the widgets again. Editing If any input box is currently being edited (if the value that the user enters differs from where the actual TS are), then the background of that box will turn red to make it clear what the user is changing. Prestart Once the user is ready to run the test, they can hit the 'Start' button. This will trigger two things: It will popup a dialog window that asks the user to verify starting and will also calculate the amount of time it will take to move the wind TS and display it on the timer. The stage won't start until the user verfies the start from the dialog. Altitude Moving If the user changes both the wind TS position and the altitude TS position, the alt TS will move first. The timer won't start and the wind TS won't move until the alt TS has moved to its final destination. While the alt TS is moving, the background of the input box will change back to its normal color. Most of the editable widgets are disabled while either of the TS are running to prevent fields from being edited while they move. Note: The user can stop motion at any time with the 'Stop' button. This button will stop the timer, stop the stages, and enable all of the widgets. Wind Moving Once the alt TS has finished moving, both the timer and the wind TS will start moving. Similar to the alt TS, the background of the input box will change from red to white once the TS starts moving. Other GUIs At any time, the user can connect to external GUIs, such as NGS and LGS AO setup. This can be done by hitting the 'Other GUIs' dropdown menu at the top menu bar and selecting any of the GUIs. !To-do note: fix the naming!!","title":"User Manual"},{"location":"#telsim-gui-user-manual","text":"Author: Preston Ito Last updated: 22 July 2022","title":"TelSIM GUI User Manual"},{"location":"#opening-gui","text":"!To-do Note: Figure out how to make it executable anywhere. Then change this part. While in the directory /usr/local/home/pito/kroot/src/kss/ao/tsim/TelSimGUI run the following command: kpython3 1SMGUI.py","title":"Opening GUI"},{"location":"#workflow","text":"The user will open the GUI from within their VNC Enable GUI and startup telescope simulator with the 'Setup TelSIM' button The user will change any desired parameters: Wind TS: position, velocity, acceleration Alt TS: position Loop Control: open/closed TS Connections: on/off Binned Mode: bin/unbinned Import File: The user can choose to import a .txt file to auto run different tests Once the user has finished changing everything they want, start running the test with 'Start' button. When the 'Start' button is pressed initially, the timer will change to display the (rough) time it will take for the Wind TS to get to its position, but nothing will start until the user verifies the start from a popup. Once the start is verified, the alt TS will move to its desired position. After it reaches its destination, only then will the wind TS and timer start. Note: The timer doesn't run for the Alt TS, only for the Wind TS. If the test needs to be stopped in the middle of a test, stop all movement with the 'Stop' button To open other GUI's, hit the 'Other GUIs' dropdown in the top menu and select desired GUI. Note: Might need to do ssh-keygen to authenticate account with GUI permissions Once the user is done, hit the 'Close TelSIM' button to disable GUI and \"home\" the positions of the two translation stages","title":"Workflow"},{"location":"#states","text":"","title":"States"},{"location":"#off","text":"When first opening the GUI, it will look like this. All of the editable widgets will be disabled, with the exception of the 'Start TelSIM' button. This button is the only way to enable everything upon startup.","title":"Off"},{"location":"#idle","text":"After clicking the 'Start TelSIM' button, all of the editable widgets will be enabled and the user can edit parameters as they wish. Also, the 'Start TelSIM' button will turn into a 'Close TelSIM' button that will reset the TS positions and disabled all the widgets again.","title":"Idle"},{"location":"#editing","text":"If any input box is currently being edited (if the value that the user enters differs from where the actual TS are), then the background of that box will turn red to make it clear what the user is changing.","title":"Editing"},{"location":"#prestart","text":"Once the user is ready to run the test, they can hit the 'Start' button. This will trigger two things: It will popup a dialog window that asks the user to verify starting and will also calculate the amount of time it will take to move the wind TS and display it on the timer. The stage won't start until the user verfies the start from the dialog.","title":"Prestart"},{"location":"#altitude-moving","text":"If the user changes both the wind TS position and the altitude TS position, the alt TS will move first. The timer won't start and the wind TS won't move until the alt TS has moved to its final destination. While the alt TS is moving, the background of the input box will change back to its normal color. Most of the editable widgets are disabled while either of the TS are running to prevent fields from being edited while they move. Note: The user can stop motion at any time with the 'Stop' button. This button will stop the timer, stop the stages, and enable all of the widgets.","title":"Altitude Moving"},{"location":"#wind-moving","text":"Once the alt TS has finished moving, both the timer and the wind TS will start moving. Similar to the alt TS, the background of the input box will change from red to white once the TS starts moving.","title":"Wind Moving"},{"location":"#other-guis","text":"At any time, the user can connect to external GUIs, such as NGS and LGS AO setup. This can be done by hitting the 'Other GUIs' dropdown menu at the top menu bar and selecting any of the GUIs. !To-do note: fix the naming!!","title":"Other GUIs"},{"location":"about/","text":"About KAPA Telescope Simulator The Keck All-sky Precision Adaptive-optics (KAPA) project will be a next-generation tomographic laser AO system, projected to begin operation at the W.M. Keck Observatory in 2024. To test their AO algorithm, Keck has built a Telescope Simulator that simulates the KAPA system on a smaller scale and more controlled environment. The KAPA Telescope Simulator is being further modified to include a turbulence simulator, which includes a glass phase screen, to simulate typical atmospheric turbulence at various altitudes and wind speeds. This simulator must move extremely precisely in two-dimensions, and will do so via two precision translation stages. GUI The turbulence simulator requires control from a GUI that adjusts different parameters necessary for the AO simulator\u2019s function. This GUI will also control some AO parameters, such as the wavefront sensor\u2019s gain, and frame rate, as well as have the ability to invoke other AO operational GUIs. The ultimate goal of this project was to create intuitive software that could be used by astronomers and engineers alike.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#kapa-telescope-simulator","text":"The Keck All-sky Precision Adaptive-optics (KAPA) project will be a next-generation tomographic laser AO system, projected to begin operation at the W.M. Keck Observatory in 2024. To test their AO algorithm, Keck has built a Telescope Simulator that simulates the KAPA system on a smaller scale and more controlled environment. The KAPA Telescope Simulator is being further modified to include a turbulence simulator, which includes a glass phase screen, to simulate typical atmospheric turbulence at various altitudes and wind speeds. This simulator must move extremely precisely in two-dimensions, and will do so via two precision translation stages.","title":"KAPA Telescope Simulator"},{"location":"about/#gui","text":"The turbulence simulator requires control from a GUI that adjusts different parameters necessary for the AO simulator\u2019s function. This GUI will also control some AO parameters, such as the wavefront sensor\u2019s gain, and frame rate, as well as have the ability to invoke other AO operational GUIs. The ultimate goal of this project was to create intuitive software that could be used by astronomers and engineers alike.","title":"GUI"},{"location":"documentation/","text":"Code Documentation Details (directory, imports, etc.) Code/.ui file directory This project is locally stored on vm-contractor1. The two components needed for this project are the python file and the .ui file. The .ui file is essentialy the layout of the GUI, and is created in Qt Designer. Both files can be found at: /usr/local/home/pito/kroot/src/kss/ao/tsim/TelSimGUI The final python file is called telsim.py and the final .ui file is called telsim.ui One can add/remove widgets to the .ui file and reconfigure them accordingly. Breaking the layout is necessary to reformatting the widgets. Imports and KPython Address These are all the imports necessary for the code. It also has KPython address and sets up EPICS channels for translation stage simulators. A good chunk of this code comes from another GUI project created by Paul Richards. His source code was used as a template for this GUI. #! @KPYTHON3@ # # kpython safely sets RELDIR, KROOT, LROOT, and PYTHONPATH before invoking # the actual Python interpreter. import os # Setup an EPICS address list if one is not already defined addrs = 'localhost:5064 vm-k1epicsgateway:5064 vm-k2epicsgateway:5064 k1aoserver-new:8607 localhost:5555 localhost:5556 k1aoserver-new:5064' # addrs = 'localhost:5064 vm-k1epicsgateway:5064 vm-k2epicsgateway:5064 k1aoserver-new:5064 localhost:5555 localhost:5556' print(f'Overriding EPICS address list to: {addrs}') os.environ['EPICS_CA_ADDR_LIST'] = addrs os.environ['EPICS_CA_AUTO_ADDR_LIST'] = 'NO' # Keck library includes import ktl # provided by kroot/ktl/keyword/python import kPyQt # provided by kroot/kui/kPyQt import logging, coloredlogs import argparse import sys import base64 from dateutil.parser import isoparse import requests import io from enum import Enum, auto import urllib import functools import subprocess import time import math from PyQt5 import QtCore, QtWidgets, uic from PyQt5.QtWidgets import QStatusBar, QMessageBox, QWidget, QVBoxLayout, QLabel, QPushButton, \\ QToolButton, QSpacerItem, QSizePolicy, QFileDialog, QShortcut, QLCDNumber, QLayout from PyQt5.QtCore import Qt, QSize, QTimer from PyQt5.QtGui import QFont, QIcon, QPixmap, QImage, QIntValidator, QDoubleValidator, QKeySequence from PyQt5.Qt import QApplication from PToggle import PToggle, PAnimatedToggle Constants, showDialog function, and state machine class These are all of the constants used throughout the code. A showDialog function is included to be called whenever QMessageBoxes are used. The code was structured using state machines. debug = False SECONDS = 1 UNBINNED_MODE = 2000 BINNED_MODE = 3600 WIND_POS_HOME = 0.00 VEL_HOME = 2.00 ACCEL_HOME = 0.10 ALT_POS_HOME = 5.0 STOP = \"0\" MOVE = \"3\" WIND_POS_MIN = -40.00 WIND_POS_MAX = 40.00 VEL_MIN = 2.00 VEL_MAX = 80.00 ACCEL_MIN = 0.00 ACCEL_MAX = 10.00 ALT_MIN = 5.0 ALT_MAX = 12.0 GAIN_MIN = 0 GAIN_MAX = 1 FRAMERATE_MIN = 1 TIMEOUT_MS = 45000 STATUS_RED_STYLE = 'background-color: rgb(255, 0, 0);' # STATUS_GREEN_STYLE = 'background-color: rgb(0, 255, 0);' MESSAGE_LIMIT = 100 class TelSimStates(Enum): INIT = 0 OFF = auto() IDLE = auto() MOVE_ALT = auto() AWAIT_ALT = auto() MOVE_WIND = auto() AWAIT_WIND = auto() STOPPED = auto() CLEANUP = auto() AWAIT_CLEANUP = auto() def showDialog(text, yes=False, cancel=False): ''' Show a message box to the user. :param text: The message to be displayed. :param yes: Use \"Yes/No\" instead of \"OK/Cancel\" :param cancel: Show a Cancel button, versus just OK. :return: True if 'Ok' or 'Yes' is pressed, False if not. ''' # Create a message box msgBox = QtWidgets.QMessageBox() msgBox.setIcon(QMessageBox.Information) msgBox.setText(text) msgBox.setWindowTitle('Message') # Add buttons, either OK or OK+Cancel or Yes+No if yes: msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No) elif cancel: msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel) else: msgBox.setStandardButtons(QMessageBox.Ok) # Test the return from the message box returnValue = msgBox.exec() if returnValue in [QMessageBox.Ok, QMessageBox.Yes]: return True else: return False The initializer function # ----------------------------------------------------------------------------- def __init__(self, *args, **kwargs): # self.list = None self.popups = {} self.template = None # Make access to data be thread safe with a mutex (chart data, in particular) self._mutex = QtCore.QMutex() QtWidgets.QMainWindow.__init__(self, *args, **kwargs) # Load the UI file uifile = 'telsim.ui' path = '.' filename = os.path.join(path, uifile) if not os.path.exists(filename): filename = os.path.join(os.environ['KROOT'], 'rel/ao/default/data', uifile) uic.loadUi(filename, self) To load a new .ui file, change the line: uifile = '{NEW_FILE.UI}' Setup UI This is where all of the setup occurs; Everything from setting the GUI title to connecting to simulator channels. Display Some display features are edited here. A list of widgets are kept to enable/disable with ease. def setupUI(self, channels=None): title = 'Telescope Simulator GUI' self.setWindowTitle(title) # ----------------------------------------------------------------------------- # Make the menu bar work the same across all platforms (looking at you, MacOS) self.menubar.setNativeMenuBar(False) # Enabling/disabling feature when TelSIM button pressed self.controls = [self.windTSBox, self.TSBox, self.altGroupBox, self.wavefrontGroupBox, self.fileGroupBox, self.loopocBox, self.loopControlLabel] Timers The countdownTimer (the timer used for the display countdown while Wind TS is moving) is created here. 'Setting single shot' ensures that the timer only runs once and doesn't keep repeating once it finishes counting down. # Timers self.countdownTimer = QTimer() # Display timer self.countdownTimer.setSingleShot(True) self.LCDnumbers.display(\"0.00\") self.secondsToMove = 0 Actions Connects buttons/text fields/radio buttons to their respective functions. For the input boxes, set a boolean attribute to ensure background color change only when user is editing (and not when it gets signals from the channel). The input validator code can be found on the left sidebar under 'Input Verification and Writing' or by clicking here. # Actions! Connects buttons/text fields to functions self.selectFileButton.clicked.connect(self.fileSelection) self.reconstructorButton.clicked.connect(self.reconstructorSelection) self.openLoop.clicked.connect(self.openLoopButton_clicked) self.closedLoop.clicked.connect(self.closeLoopButton_clicked) self.bin.toggled.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) self.unbin.toggled.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) # Creates 'changed' attributes for the background color feature while editing setattr(self.posBox, 'changed', False) self.posBox.editingFinished.connect(lambda: self.posCheck(self.posBox.text())) self.posBox.textChanged.connect(lambda: self.editTextChanged(self.posBox)) setattr(self.velBox, 'changed', False) self.velBox.editingFinished.connect(lambda: self.velCheck(self.velBox.text())) self.velBox.textChanged.connect(lambda: self.editTextChanged(self.velBox)) setattr(self.accelBox, 'changed', False) self.accelBox.editingFinished.connect(lambda: self.accelCheck(self.accelBox.text())) self.accelBox.textChanged.connect(lambda: self.editTextChanged(self.accelBox)) setattr(self.altBox, 'changed', False) self.altBox.editingFinished.connect(lambda: self.altCheck(self.altBox.text())) self.altBox.textChanged.connect(lambda: self.editTextChanged(self.altBox)) setattr(self.gainInput, 'changed', False) self.gainInput.editingFinished.connect(lambda: self.gainCheck(self.gainInput.text())) self.gainInput.textChanged.connect(lambda: self.editTextChanged(self.gainInput)) setattr(self.frameRateInput, 'changed', False) self.frameRateInput.editingFinished.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) self.frameRateInput.textChanged.connect(lambda: self.editTextChanged(self.frameRateInput)) Channels Connects to the different channels using kPyQt. kPyQt documentation can be found here on Keck's website. The different types are RBV (read back value), VAL (position value), VELO (velocity), ACCL (acceleration), MOVN (returns moving status), SPMG (returns one of these values: Stop, Pause, Move, Go). Writing a position value must be done to the .VAL, while reading back it's position is done through .RBV. Note: These channels are to connect to the emulator, and will need to be replaced once the real stages get setup. # Channel creation for the emulator self.posChan = kPyQt.caFactory(\"wndsim:ln:m1.RBV\", kPyQt.Channel.caFloat) self.posWritingChan = kPyQt.caFactory(\"wndsim:ln:m1.VAL\", kPyQt.Channel.caFloat) self.posMovingChan = kPyQt.caFactory(\"wndsim:ln:m1.MOVN\", kPyQt.Channel.caFloat) self.velChan = kPyQt.caFactory(\"wndsim:ln:m1.VELO\", kPyQt.Channel.caFloat) self.accelChan = kPyQt.caFactory(\"wndsim:ln:m1.ACCL\", kPyQt.Channel.caFloat) self.altChan = kPyQt.caFactory(\"altsim:ln:m1.RBV\", kPyQt.Channel.caFloat) self.altWritingChan = kPyQt.caFactory(\"altsim:ln:m1.VAL\", kPyQt.Channel.caFloat) self.altMovingChan = kPyQt.caFactory(\"altsim:ln:m1.MOVN\", kPyQt.Channel.caFloat) self.windStopChan = kPyQt.caFactory(\"wndsim:ln:m1.SPMG\", kPyQt.Channel.caFloat) self.altStopChan = kPyQt.caFactory(\"altsim:ln:m1.SPMG\", kPyQt.Channel.caFloat) AO Keywords These are the keywords for the AO wavefront sensor and loop control. Callbacks are intialized during the INIT state. Note: These keywords might have to be changed once the AO system is configured for the new RTC. service = 'ao1' ao1 = ktl.cache(service) # ----------------------------------------------------------------------------------------- # A label attached to an KTL string keyword dt_key = 'dtlp' self.dt_keyword = kPyQt.kFactory(ao1[dt_key]) dm_key = 'dmlp' self.dm_keyword = kPyQt.kFactory(ao1[dm_key]) fr_key = 'wsfrrt' # Alternate keyword for frame rate for now (framerate keyword is not configured for the new RTC). Actual keyword is o1fps self.frameRate_keyword = kPyQt.kFactory(ao1[fr_key]) # gain_key = 'dtgain' # Fake keyword for gain for now (gain keyword is not configured for the new RTC). Actual keyword is o1wgs self.gain_keyword = kPyQt.caFactory('k1:ao:wc:dt:sv:gain', kPyQt.Channel.caFloat) Toggle Visual Note: PToggle is a separate python file that was imported at the top of the code. The toggle code can be found here. Below is the section that implements PToggle to create a toggle button for the two translation stage's connection status. # ------ Translation stages' toggles -------------------------------------------- self.TS1 = PToggle(handle_color=Qt.red, checked_color=Qt.green) TS1lay = QVBoxLayout() TS1lay.addWidget(self.TS1) self.TS1tog.setLayout(TS1lay) self.TS1.setCheckState(Qt.Unchecked) self.TS2 = PToggle(handle_color=Qt.red, checked_color=Qt.green) TS2lay = QVBoxLayout() TS2lay.addWidget(self.TS2) self.TS2tog.setLayout(TS2lay) self.TS2.setCheckState(Qt.Unchecked) State machine support Code that connects some functions necessary to transition between states in the state machine. self.setupTelSIMButtonWasPressed = False self.setupTelSIMButton.clicked.connect(self.setupTelSIMButtonPressed) self.closeTelSIMButtonWasPressed = False self.closeTelSIMButton.clicked.connect(self.closeTelSIMButtonPressed) self.startButtonWasPressed = False self.startButton.clicked.connect(self.startButtonPressed) self.stopButtonWasPressed = False self.stopButton.clicked.connect(self.stopButtonPressed) self.stateTimeout = QTimer() self.stateTimeout.setSingleShot(True) self.stateMachineTimer = QTimer() self.stateMachineTimer.timeout.connect(self.stateMachine) self.stateMachineTimer.start(75) self.state = TelSimStates.INIT Functions to trigger states Creation of the actual functions connected to the buttons (start, stop, setupTelSIM, closeTelSIM). def setupTelSIMButtonPressed(self): \"\"\" Trigger the state machine with a button press. :return: \"\"\" self.setupTelSIMButtonWasPressed = True def closeTelSIMButtonPressed(self): \"\"\" Trigger the state machine with a button press. :return: \"\"\" self.closeTelSIMButtonWasPressed = True def startButtonPressed(self): \"\"\" Trigger MOVE_ALT stage with a button press. :return: \"\"\" self.startButtonWasPressed = True def stopButtonPressed(self): \"\"\" Trigger MOVE_ALT stage with a button press. :return: \"\"\" self.stopButtonWasPressed = True State Machine Function that starts the state machine. def stateMachine(self): \"\"\" State machine processing. :return: \"\"\" self.statusbar.showMessage(f'STATE: {self.state.name}') State: INIT The INIT state runs all the callbacks to the channels and keywords. Having a separate state that does this ensures that the callbacks only happen once when the program is first opened. # ----- STATE 0 ------------------------------------------------ if self.state == TelSimStates.INIT: # Connects to the channels to read and display the values self.posChan.floatCallback.connect(self.posBoxSetText) self.posChan.runCallbacks() self.velChan.floatCallback.connect(self.velBoxSetText) self.velChan.runCallbacks() self.accelChan.floatCallback.connect(self.accelBoxSetText) self.accelChan.runCallbacks() self.altChan.floatCallback.connect(self.altBoxSetText) self.altChan.runCallbacks() self.dt_keyword.stringCallback.connect(self.loopController) self.dt_keyword.primeCallback() self.dm_keyword.stringCallback.connect(self.loopController) self.dm_keyword.primeCallback() self.frameRate_keyword.stringCallback.connect(self.frBoxSetText) self.frameRate_keyword.primeCallback() self.gain_keyword.floatCallback.connect(self.gainBoxSetText) self.gain_keyword.runCallbacks() self.state = TelSimStates.OFF return State: OFF The OFF state has everything disabled except for the setupTelSIM button. Transitions to ON state if setupTelSIM button was pressed. # ----- STATE 1 ------------------------------------------------ elif self.state == TelSimStates.OFF: # Update GUI widgets for the OFF state self.startButton.setVisible(True) self.startButton.setEnabled(False) self.stopButton.setVisible(False) self.setupTelSIMButton.setEnabled(True) self.setupTelSIMButton.setVisible(True) self.closeTelSIMButton.setEnabled(False) self.closeTelSIMButton.setVisible(False) for i in self.controls: i.setEnabled(False) # Disable the widgets # If setup is pressed, advance to IDLE if self.setupTelSIMButtonWasPressed: self.setupTelSIMButtonWasPressed = False # Advance the state machine self.state = TelSimStates.IDLE return return State: ON The ON state connects the callbacks to start displaying the constant refreshing of the pos/vel/accel/alt values. Note: This had to be separated from the IDLE state because .runCallbacks() only needed to be called once upon starting up. Otherwise, the input boxes would always refresh and make it difficult for the user to edit. # ----- STATE 2 ----------------------------------------- elif self.state == TelSimStates.IDLE: # Update GUI widgets visibility self.startstopBox.setEnabled(True) self.startButton.setVisible(True) self.startButton.setEnabled(True) self.stopButton.setVisible(False) self.stopButton.setEnabled(False) self.setupTelSIMButton.setEnabled(False) self.setupTelSIMButton.setVisible(False) self.closeTelSIMButton.setEnabled(True) self.closeTelSIMButton.setVisible(True) self.LCDnumbers.display(\"0.00\") for i in self.controls: i.setEnabled(True) # Enable the widgets if self.startButtonWasPressed: self.startButtonWasPressed = False self.state = TelSimStates.MOVE_ALT return if self.closeTelSIMButtonWasPressed: self.closeTelSIMButtonWasPressed = False self.state = TelSimStates.CLEANUP return return State: IDLE The IDLE state enables all of the input widgets and waits for the user to hit the Start button or the closeTelSIM button and changes the state accordingly. # ----- STATE 3 ----------------------------------------- elif self.state == TelSimStates.MOVE_ALT: self.finalPos = self.posBox.text() self.finalAlt = self.altBox.text() self.initialPos = float(self.posChan.read()) self.secondsToMove = abs(float(self.initialPos) - float(self.finalPos)) / float( self.velBox.text()) # Note: self.velBox.text() is only assigned after being validated self.LCDnumbers.display(f\"{self.secondsToMove:0.2f}\") self.initialAlt = float(self.altChan.read()) if showDialog(\"Are you sure you want to START?\", yes=True, cancel=True): for i in self.controls: i.setEnabled(False) # Disable the widgets self.startButton.setVisible(False) self.startButton.setEnabled(False) self.stopButton.setVisible(True) self.stopButton.setEnabled(True) self.altStopChan.write(MOVE) self.altWrite(self.altBox.text()) self.altBox.changed = False self.stateTimeout.start(TIMEOUT_MS) self.state = TelSimStates.AWAIT_ALT return else: self.state = TelSimStates.IDLE return State: MOVE_ALT The MOVE_ALT state does a rough calculation of amount of time to move the wind TS (the timer is only used for the wind TS, not the alt TS. The timer and the wind TS doesn't actually start running until the alt TS has finished moving) and stores that in self.secondsToMove . It also uses the showDialog function (shown in the Details section) to ask the user to verify the start. Once verified, it will write '3' to the .SPMG channel (3 is equal to 'MOVE', in case it's currently stopped) before writing the value in the altbox to the .VAL channel. Transition to the AWAIT_ALT state is automatic once these values have been written. # ----- STATE 3 ----------------------------------------- elif self.state == TelSimStates.MOVE_ALT: self.finalPos = self.posBox.text() self.finalAlt = self.altBox.text() self.initialPos = float(self.posChan.read()) self.secondsToMove = abs(float(self.initialPos) - float(self.finalPos)) / float(self.velBox.text()) print(self.secondsToMove) self.LCDnumbers.display(f\"{self.secondsToMove:0.2f}\") self.initialAlt = float(self.altChan.read()) if showDialog(\"Are you sure you want to START?\", yes=True, cancel=True): for i in self.controls: i.setEnabled(False) # Disable the widgets self.startButton.setVisible(False) self.startButton.setEnabled(False) self.stopButton.setVisible(True) self.stopButton.setEnabled(True) print(\"altBox.text: \" + self.altBox.text()) # if self.altStopChan.read() == \"0\": self.altStopChan.write(\"3\") self.altWrite(self.altBox.text()) self.altBox.changed = False self.state = TelSimStates.AWAIT_ALT return else: self.state = TelSimStates.IDLE return State: AWAIT_ALT Waits for the alt TS to get to its destination. Once it reaches its destination, transitions to the MOVE_WIND state. If Stop button was pressed, transitions to STOPPED state. # ----- STATE 4 ----------------------------------------- elif self.state == TelSimStates.AWAIT_ALT: if math.isclose(float(self.altChan.read()), float(self.finalAlt), abs_tol=0.05): self.stateTimeout.stop() self.stateTimeout.start(TIMEOUT_MS) self.state = TelSimStates.MOVE_WIND return if self.stopButtonWasPressed: self.stateTimeout.stop() self.stopButtonWasPressed = False self.state = TelSimStates.STOPPED return if not self.stateTimeout.isActive(): raise TimeoutError(\"Alt TS took more than 45 seconds to move\") return return State: MOVE_WIND Acts similarly to the MOVE_ALT state. Also starts the timer with the self.secondsToMove value calculated in the MOVE_ALT state. Transitions to AWAIT_WIND state automatically. # ----- STATE 5 ----------------------------------------- elif self.state == TelSimStates.MOVE_WIND: self.posBox.changed = False self.velBox.changed = False self.accelBox.changed = False self.windStopChan.write(MOVE) self.accelWrite(self.accelBox.text()) self.velWrite(self.velBox.text()) self.posWrite(self.posBox.text()) self.countdownTimer.start(int(self.secondsToMove) * 1000) self.stateTimeout.start(TIMEOUT_MS) self.state = TelSimStates.AWAIT_WIND return State: AWAIT_WIND Acts similarly to the AWAIT_ALT state. Once the wind TS reaches its destination, transitions to the IDLE state. # ----- STATE 6 ----------------------------------------- elif self.state == TelSimStates.AWAIT_WIND: self.timeLeft = self.countdownTimer.remainingTime() / 1000 self.LCDnumbers.display(f\"{self.timeLeft:0.2f}\") if math.isclose(float(self.posChan.read()), float(self.finalPos), abs_tol=0.05): self.stateTimeout.stop() self.state = TelSimStates.IDLE return if self.stopButtonWasPressed: self.stopButtonWasPressed = False self.stateTimeout.stop() self.state = TelSimStates.STOPPED return if not self.stateTimeout.isActive(): raise TimeoutError(\"Wind TS took more than 45 seconds to move\") return return State: STOPPED Writes '0' to the two .SPMG channels ('0' is equal to 'Stop') and stops the timer. Automatically transitions to IDLE state. # ----- STATE 7 ----------------------------------------- elif self.state == TelSimStates.STOPPED: self.windStopChan.write(STOP) self.altStopChan.write(STOP) self.countdownTimer.stop() self.state = TelSimStates.IDLE return State: CLEANUP Enables/disables widgets accordingly. Sends the two TS to their 'home' position. Automatically transitions to AWAIT_CLEANUP state. # ----- STATE 8 ----------------------------------------- elif self.state == TelSimStates.CLEANUP: self.closeTelSIMButton.setVisible(False) self.closeTelSIMButton.setEnabled(False) self.setupTelSIMButton.setVisible(True) self.setupTelSIMButton.setEnabled(False) self.startstopBox.setEnabled(False) for i in self.controls: i.setEnabled(False) self.windStopChan.write(MOVE) self.altStopChan.write(MOVE) self.posWrite(WIND_POS_HOME) self.velWrite(VEL_HOME) self.accelWrite(ACCEL_HOME) self.altWrite(ALT_POS_HOME) time.sleep(2) self.stateTimeout.start(TIMEOUT_MS) self.state = TelSimStates.AWAIT_CLEANUP return State: AWAIT_CLEANUP Waits for the two TS to get to their 'home' position before transitioning to OFF state. # ----- STATE 9 ----------------------------------------- elif self.state == TelSimStates.AWAIT_CLEANUP: if int(self.altMovingChan.read()) == 0: if int(self.posMovingChan.read()) == 0: if math.isclose(float(self.accelChan.read()), 0.2, abs_tol=0.2): if math.isclose(float(self.velChan.read()), 2.1, abs_tol=0.2): self.state = TelSimStates.OFF return if not self.stateTimeout.isActive(): raise TimeoutError(\"Cleanup took more than 45 seconds\") return return Color changing editTextChanged and editFinished These functions are responsible for changing the background color to red while the user is inputting a value, and changing it back once they're finished. # ------------------------------------------------------- def editTextChanged(self, edit): '''Qt signal that something was typed in the edit field''' edit.changed = True edit.setStyleSheet('background-color: red') # -------------------------------------------------------- def editFinished(self, edit): '''Qt signal that the edit field lost focus when editing, revert the value''' if edit.changed: edit.setText(edit.undoText) edit.changed = False edit.setStyleSheet(self.editStyleSheet) Receiving signals from stage These functions use the attribute 'changed' (that was created in the Setup UI section) to prevent changing the color to red if it's receiving signals from the stage. That way, it'll only change to red if the user is inputting changes. def posBoxSetText(self, val): if not self.posBox.changed: self.posBox.setStyleSheet(\"\") self.posBox.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.posBox.setText(f\"{val:0.2f}\") self.posBox.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def velBoxSetText(self, val): if not self.velBox.changed: self.velBox.setStyleSheet(\"\") self.velBox.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.velBox.setText(f\"{val:0.2f}\") self.velBox.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def accelBoxSetText(self, val): if not self.accelBox.changed: self.accelBox.setStyleSheet(\"\") self.accelBox.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.accelBox.setText(f\"{val:0.2f}\") self.accelBox.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def altBoxSetText(self, val): if not self.altBox.changed: self.altBox.setStyleSheet(\"\") self.altBox.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.altBox.setText(f\"{val:0.1f}\") self.altBox.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def frBoxSetText(self, val): if not self.frameRateInput.changed: self.frameRateInput.setStyleSheet(\"\") self.frameRateInput.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.frameRateInput.setText(f\"{val}\") self.frameRateInput.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def gainBoxSetText(self, val): if not self.gainInput.changed: self.gainInput.setStyleSheet(\"\") self.gainInput.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.gainInput.setText(f\"{val:0.2f}\") self.gainInput.blockSignals(False) # Turn on signals to the edit, a human is not editing it! Input Verification and Writing Validators These functions make sure that the value entered in the field is within bounds. If the user is finished editing (clicks away), then the showDialog function is used to give an error message. # --- Corrects pos/vel/accel/alt values after edited? -------------------- def posCheck(self, msg): ''' Makes sure the value entered in the field is within bounds. If not, will show error message. Also assigns self.finalPos used later for calculating time it will take to move :param msg: Value entered in posBox text box ''' self.posBox.validator = QDoubleValidator(WIND_POS_MIN, WIND_POS_MAX, 2, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.posBox.validator, str(msg), 0)[ 0] != 2: # When this object is != 2, that means that it's not an acceptable input self.posBox.setText(f\"{float(self.posChan.read()):0.2f}\") showDialog(\"Position must be a float between -40.00 and 40.00\") def velCheck(self, msg): self.velBox.validator = QDoubleValidator(VEL_MIN, VEL_MAX, 2, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.velBox.validator, str(msg), 0)[0] != 2: self.velBox.setText(f\"{float(self.velChan.read()):0.2f}\") showDialog(\"Velocity must be a float between 2.00 and 80.00\") else: # Ensures self.velVal assignment ONLY if the input passes the validator self.velVal = msg def accelCheck(self, msg): self.accelBox.validator = QDoubleValidator(ACCEL_MIN, ACCEL_MAX, 2, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.accelBox.validator, str(msg), 0)[0] != 2: self.accelBox.setText(f\"{float(self.accelChan.read()):0.2f}\") showDialog(\"Acceleration must be a float between 0.00 and 10.00\") def gainCheck(self, msg): self.gainInput.validator = QDoubleValidator(GAIN_MIN, GAIN_MAX, 2, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.gainInput.validator, str(msg), 0)[0] != 2: self.gainInput.setText(f\"{float(self.gain_keyword.read()):0.2f}\") showDialog(\"Gain must be between 0 and 1\") else: self.gain_keyword.write(msg) self.gainInput.changed = False def altCheck(self, msg): self.altBox.validator = QDoubleValidator(ALT_MIN, ALT_MAX, 1, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.altBox.validator, str(msg), 0)[0] != 2: self.altBox.setText(f\"{float(self.altChan.read()):0.1f}\") showDialog(\"Altitude must be between 5.0 and 12.0\") def frameRateCheck(self, msg): if self.unbin.isChecked() == True: self.frameRateInput.validator = QIntValidator(FRAMERATE_MIN, UNBINNED_MODE, self) else: self.frameRateInput.validator = QIntValidator(FRAMERATE_MIN, BINNED_MODE, self) if QIntValidator.validate(self.frameRateInput.validator, str(msg), 0)[0] != 2: self.frameRateInput.setText(\"1\") showDialog(\"Frame rate must be integer between 1-2000 when in unbinned mode and \" \"1-3600 when in binned mode; automatically reset frame to 1\") else: self.frameRate_keyword.write(msg) self.frameRateInput.changed = False Writing to channel These functions write the value passed through to the appropriate channel. The wait=False in the position and altitude writing channels are necessary to allow the user to stop the motion while the stages are moving to their destination. # ---- Writes the pos/vel/accel/alt to the emulator -------------------------------------------- def posWrite(self, msg): ''' Writes the value to the writing channel :param msg: Position value ''' f = float(msg) self.posWritingChan.write(f, wait=False) def velWrite(self, msg): f = float(msg) self.velChan.write(f) def accelWrite(self, msg): f = float(msg) self.accelChan.write(f) def altWrite(self, msg): f = float(msg) self.altWritingChan.write(f, wait=False) Loop Control These functions are responsible for displaying the correct radio button for loop control, and sending the write signals when each button is pressed. def loopController(self): \"\"\" Selects the correct radio button based on status of dmlp and dtlp keywords \"\"\" if self.dt_keyword.read() == \"CLOSE\" and self.dm_keyword.read() == \"CLOSE\": self.closedLoop.setChecked(True) else: self.openLoop.setChecked(True) def openLoopButton_clicked(self): \"\"\" Turns loop off (opens loop) \"\"\" if self.dt_keyword.read() == \"CLOSE\" or self.dm_keyword.read() == \"CLOSE\": self.dm_keyword.write(\"OPEN\") time.sleep(0.5) self.dt_keyword.write(\"OPEN\") def closeLoopButton_clicked(self): \"\"\" Turns loop on (closes loop) \"\"\" if self.dt_keyword.read() == \"OPEN\" or self.dm_keyword.read() == \"OPEN\": self.dt_keyword.write(\"CLOSE\") time.sleep(0.5) self.dm_keyword.write(\"CLOSE\") Main function This is the standard startup main function for all kPyQt GUIs. if __name__ == '__main__': # ------------------------------------------------------------------------- # Commandline arguments parser = argparse.ArgumentParser(description='Turbulence Simulator GUI') parser.add_argument('-d', '--debug', help='Enable debugging output', action='store_true') args = parser.parse_args() # Get the debug argument first, as it drives our logging choices if args.debug: debug = True # ------------------------------------------------------------------------- # Set up the base logger all threads will use, once we know the debug flag coloredlogs.DEFAULT_LOG_FORMAT = '%(asctime)s [%(levelname)s] %(message)s' coloredlogs.DEFAULT_DATE_FORMAT = '%Y-%m-%d %H:%M:%S.%f' if debug: coloredlogs.install(level='DEBUG') else: coloredlogs.install(level='INFO') log = logging.getLogger('') # Disable the debug logging from Qt logging.getLogger('PyQt5').setLevel(logging.WARNING) application = QtWidgets.QApplication(sys.argv) mainwin = TurbulenceSimulatorGUIMain() mainwin.setupUI() # mainwin.setMinimumSize(0, 0) # mainwin.resize(10,10) mainwin.show() # Run the Qt application status = kPyQt.run(application) sys.exit(status) Toggle Code from PyQt5.QtCore import ( Qt, QSize, QPoint, QPointF, QRectF, QEasingCurve, QPropertyAnimation, QSequentialAnimationGroup, pyqtSlot, pyqtProperty) from PyQt5.QtWidgets import QCheckBox from PyQt5.QtGui import QColor, QBrush, QPaintEvent, QPen, QPainter from PyQt5.QtCore import pyqtSlot as Slot, pyqtProperty as Property class PToggle(QCheckBox): \"\"\"Derived from qtwidgets.Toggle at https://github.com/pythonguis/python-qtwidgets/blob/master/qtwidgets/toggle/toggle.py\"\"\" _transparent_pen = QPen(Qt.transparent) _light_grey_pen = QPen(Qt.lightGray) _dark_gray_pen = QPen(Qt.darkGray) def __init__(self, parent=None, bar_color=Qt.gray, checked_color=\"#00B0FF\", handle_color=Qt.white, ): super().__init__(parent) # Save our properties on the object via self, so we can access them later # in the paintEvent. self._bar_brush = QBrush(bar_color) self._bar_checked_brush = QBrush(QColor(checked_color).lighter()) self._bar_partially_checked_brush = QBrush(Qt.gray) self._handle_brush = QBrush(handle_color) self._handle_checked_brush = QBrush(QColor(checked_color)) self._handle_partially_checked_brush = QBrush(Qt.gray) self._handle_disabled_brush = QBrush(Qt.darkGray) # Setup the rest of the widget. self.setContentsMargins(8, 0, 8, 0) self._handle_position = 0 self.stateChanged.connect(self.handle_state_change) def sizeHint(self): return QSize(58, 45) def hitButton(self, pos: QPoint): return self.contentsRect().contains(pos) def paintEvent(self, e: QPaintEvent): contRect = self.contentsRect() handleRadius = round(0.24 * contRect.height()) p = QPainter(self) p.setRenderHint(QPainter.Antialiasing) p.setPen(self._transparent_pen) barRect = QRectF( 0, 0, contRect.width() - handleRadius, 0.40 * contRect.height() ) barRect.moveCenter(contRect.center()) rounding = barRect.height() / 2 # the handle will move along this line trailLength = contRect.width() - 2 * handleRadius xPos = contRect.x() + handleRadius + trailLength * self._handle_position if self.checkState() == Qt.PartiallyChecked: p.setBrush(self._bar_partially_checked_brush) p.drawRoundedRect(barRect, rounding, rounding) # Don't draw the handle if partially checked! elif self.checkState() == Qt.Checked: p.setBrush(self._bar_checked_brush) p.drawRoundedRect(barRect, rounding, rounding) if self.isEnabled(): p.setBrush(self._handle_checked_brush) else: p.setBrush(self._handle_disabled_brush) p.drawEllipse(QPointF(xPos, barRect.center().y()), handleRadius, handleRadius) # Unchecked else: p.setBrush(self._bar_brush) p.drawRoundedRect(barRect, rounding, rounding) p.setPen(self._light_grey_pen) if self.isEnabled(): p.setBrush(self._handle_brush) else: p.setBrush(self._handle_disabled_brush) p.drawEllipse(QPointF(xPos, barRect.center().y()), handleRadius, handleRadius) p.end() @Slot(int) def handle_state_change(self, value): self._handle_position = 1 if value else 0 @Property(float) def handle_position(self): return self._handle_position @handle_position.setter def handle_position(self, pos): \"\"\"change the property we need to trigger QWidget.update() method, either by: 1- calling it here [ what we're doing ]. 2- connecting the QPropertyAnimation.valueChanged() signal to it. \"\"\" self._handle_position = pos self.update() @Property(float) def pulse_radius(self): return self._pulse_radius @pulse_radius.setter def pulse_radius(self, pos): self._pulse_radius = pos self.update() class PAnimatedToggle(PToggle): _transparent_pen = QPen(Qt.transparent) _light_grey_pen = QPen(Qt.lightGray) def __init__(self, *args, pulse_unchecked_color=\"#44999999\", pulse_checked_color=\"#4400B0EE\", **kwargs): self._pulse_radius = 0 super().__init__(*args, **kwargs) self.animation = QPropertyAnimation(self, b\"handle_position\", self) self.animation.setEasingCurve(QEasingCurve.InOutCubic) self.animation.setDuration(200) # time in ms self.pulse_anim = QPropertyAnimation(self, b\"pulse_radius\", self) self.pulse_anim.setDuration(350) # time in ms self.pulse_anim.setStartValue(10) self.pulse_anim.setEndValue(20) self.animations_group = QSequentialAnimationGroup() self.animations_group.addAnimation(self.animation) self.animations_group.addAnimation(self.pulse_anim) self._pulse_unchecked_animation = QBrush(QColor(pulse_unchecked_color)) self._pulse_checked_animation = QBrush(QColor(pulse_checked_color)) @Slot(int) def handle_state_change(self, value): self.animations_group.stop() if value: self.animation.setEndValue(1) else: self.animation.setEndValue(0) self.animations_group.start() def paintEvent(self, e: QPaintEvent): contRect = self.contentsRect() handleRadius = round(0.24 * contRect.height()) p = QPainter(self) p.setRenderHint(QPainter.Antialiasing) p.setPen(self._transparent_pen) barRect = QRectF( 0, 0, contRect.width() - handleRadius, 0.40 * contRect.height() ) barRect.moveCenter(contRect.center()) rounding = barRect.height() / 2 # the handle will move along this line trailLength = contRect.width() - 2 * handleRadius xPos = contRect.x() + handleRadius + trailLength * self._handle_position # Animate, unless partially checked if self.checkState() in [Qt.Checked, Qt.Unchecked]: if self.pulse_anim.state() == QPropertyAnimation.Running: p.setBrush( self._pulse_checked_animation if self.isChecked() else self._pulse_unchecked_animation) p.drawEllipse(QPointF(xPos, barRect.center().y()), self._pulse_radius, self._pulse_radius) if self.checkState() == Qt.PartiallyChecked: p.setBrush(self._bar_partially_checked_brush) p.drawRoundedRect(barRect, rounding, rounding) # Don't draw the handle if partially checked! elif self.checkState() == Qt.Checked: p.setBrush(self._bar_checked_brush) p.drawRoundedRect(barRect, rounding, rounding) if self.isEnabled(): p.setBrush(self._handle_checked_brush) else: p.setBrush(self._handle_disabled_brush) p.drawEllipse(QPointF(xPos, barRect.center().y()),handleRadius, handleRadius) else: p.setBrush(self._bar_brush) p.drawRoundedRect(barRect, rounding, rounding) p.setPen(self._light_grey_pen) if self.isEnabled(): p.setBrush(self._handle_brush) else: p.setBrush(self._handle_disabled_brush) p.drawEllipse(QPointF(xPos, barRect.center().y()),handleRadius, handleRadius) p.end()","title":"Code Documentation"},{"location":"documentation/#code-documentation","text":"","title":"Code Documentation"},{"location":"documentation/#details-directory-imports-etc","text":"","title":"Details (directory, imports, etc.)"},{"location":"documentation/#codeui-file-directory","text":"This project is locally stored on vm-contractor1. The two components needed for this project are the python file and the .ui file. The .ui file is essentialy the layout of the GUI, and is created in Qt Designer. Both files can be found at: /usr/local/home/pito/kroot/src/kss/ao/tsim/TelSimGUI The final python file is called telsim.py and the final .ui file is called telsim.ui One can add/remove widgets to the .ui file and reconfigure them accordingly. Breaking the layout is necessary to reformatting the widgets.","title":"Code/.ui file directory"},{"location":"documentation/#imports-and-kpython-address","text":"These are all the imports necessary for the code. It also has KPython address and sets up EPICS channels for translation stage simulators. A good chunk of this code comes from another GUI project created by Paul Richards. His source code was used as a template for this GUI. #! @KPYTHON3@ # # kpython safely sets RELDIR, KROOT, LROOT, and PYTHONPATH before invoking # the actual Python interpreter. import os # Setup an EPICS address list if one is not already defined addrs = 'localhost:5064 vm-k1epicsgateway:5064 vm-k2epicsgateway:5064 k1aoserver-new:8607 localhost:5555 localhost:5556 k1aoserver-new:5064' # addrs = 'localhost:5064 vm-k1epicsgateway:5064 vm-k2epicsgateway:5064 k1aoserver-new:5064 localhost:5555 localhost:5556' print(f'Overriding EPICS address list to: {addrs}') os.environ['EPICS_CA_ADDR_LIST'] = addrs os.environ['EPICS_CA_AUTO_ADDR_LIST'] = 'NO' # Keck library includes import ktl # provided by kroot/ktl/keyword/python import kPyQt # provided by kroot/kui/kPyQt import logging, coloredlogs import argparse import sys import base64 from dateutil.parser import isoparse import requests import io from enum import Enum, auto import urllib import functools import subprocess import time import math from PyQt5 import QtCore, QtWidgets, uic from PyQt5.QtWidgets import QStatusBar, QMessageBox, QWidget, QVBoxLayout, QLabel, QPushButton, \\ QToolButton, QSpacerItem, QSizePolicy, QFileDialog, QShortcut, QLCDNumber, QLayout from PyQt5.QtCore import Qt, QSize, QTimer from PyQt5.QtGui import QFont, QIcon, QPixmap, QImage, QIntValidator, QDoubleValidator, QKeySequence from PyQt5.Qt import QApplication from PToggle import PToggle, PAnimatedToggle","title":"Imports and KPython Address"},{"location":"documentation/#constants-showdialog-function-and-state-machine-class","text":"These are all of the constants used throughout the code. A showDialog function is included to be called whenever QMessageBoxes are used. The code was structured using state machines. debug = False SECONDS = 1 UNBINNED_MODE = 2000 BINNED_MODE = 3600 WIND_POS_HOME = 0.00 VEL_HOME = 2.00 ACCEL_HOME = 0.10 ALT_POS_HOME = 5.0 STOP = \"0\" MOVE = \"3\" WIND_POS_MIN = -40.00 WIND_POS_MAX = 40.00 VEL_MIN = 2.00 VEL_MAX = 80.00 ACCEL_MIN = 0.00 ACCEL_MAX = 10.00 ALT_MIN = 5.0 ALT_MAX = 12.0 GAIN_MIN = 0 GAIN_MAX = 1 FRAMERATE_MIN = 1 TIMEOUT_MS = 45000 STATUS_RED_STYLE = 'background-color: rgb(255, 0, 0);' # STATUS_GREEN_STYLE = 'background-color: rgb(0, 255, 0);' MESSAGE_LIMIT = 100 class TelSimStates(Enum): INIT = 0 OFF = auto() IDLE = auto() MOVE_ALT = auto() AWAIT_ALT = auto() MOVE_WIND = auto() AWAIT_WIND = auto() STOPPED = auto() CLEANUP = auto() AWAIT_CLEANUP = auto() def showDialog(text, yes=False, cancel=False): ''' Show a message box to the user. :param text: The message to be displayed. :param yes: Use \"Yes/No\" instead of \"OK/Cancel\" :param cancel: Show a Cancel button, versus just OK. :return: True if 'Ok' or 'Yes' is pressed, False if not. ''' # Create a message box msgBox = QtWidgets.QMessageBox() msgBox.setIcon(QMessageBox.Information) msgBox.setText(text) msgBox.setWindowTitle('Message') # Add buttons, either OK or OK+Cancel or Yes+No if yes: msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No) elif cancel: msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel) else: msgBox.setStandardButtons(QMessageBox.Ok) # Test the return from the message box returnValue = msgBox.exec() if returnValue in [QMessageBox.Ok, QMessageBox.Yes]: return True else: return False","title":"Constants, showDialog function, and state machine class"},{"location":"documentation/#the-initializer-function","text":"# ----------------------------------------------------------------------------- def __init__(self, *args, **kwargs): # self.list = None self.popups = {} self.template = None # Make access to data be thread safe with a mutex (chart data, in particular) self._mutex = QtCore.QMutex() QtWidgets.QMainWindow.__init__(self, *args, **kwargs) # Load the UI file uifile = 'telsim.ui' path = '.' filename = os.path.join(path, uifile) if not os.path.exists(filename): filename = os.path.join(os.environ['KROOT'], 'rel/ao/default/data', uifile) uic.loadUi(filename, self) To load a new .ui file, change the line: uifile = '{NEW_FILE.UI}'","title":"The initializer function"},{"location":"documentation/#setup-ui","text":"This is where all of the setup occurs; Everything from setting the GUI title to connecting to simulator channels.","title":"Setup UI"},{"location":"documentation/#display","text":"Some display features are edited here. A list of widgets are kept to enable/disable with ease. def setupUI(self, channels=None): title = 'Telescope Simulator GUI' self.setWindowTitle(title) # ----------------------------------------------------------------------------- # Make the menu bar work the same across all platforms (looking at you, MacOS) self.menubar.setNativeMenuBar(False) # Enabling/disabling feature when TelSIM button pressed self.controls = [self.windTSBox, self.TSBox, self.altGroupBox, self.wavefrontGroupBox, self.fileGroupBox, self.loopocBox, self.loopControlLabel]","title":"Display"},{"location":"documentation/#timers","text":"The countdownTimer (the timer used for the display countdown while Wind TS is moving) is created here. 'Setting single shot' ensures that the timer only runs once and doesn't keep repeating once it finishes counting down. # Timers self.countdownTimer = QTimer() # Display timer self.countdownTimer.setSingleShot(True) self.LCDnumbers.display(\"0.00\") self.secondsToMove = 0","title":"Timers"},{"location":"documentation/#actions","text":"Connects buttons/text fields/radio buttons to their respective functions. For the input boxes, set a boolean attribute to ensure background color change only when user is editing (and not when it gets signals from the channel). The input validator code can be found on the left sidebar under 'Input Verification and Writing' or by clicking here. # Actions! Connects buttons/text fields to functions self.selectFileButton.clicked.connect(self.fileSelection) self.reconstructorButton.clicked.connect(self.reconstructorSelection) self.openLoop.clicked.connect(self.openLoopButton_clicked) self.closedLoop.clicked.connect(self.closeLoopButton_clicked) self.bin.toggled.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) self.unbin.toggled.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) # Creates 'changed' attributes for the background color feature while editing setattr(self.posBox, 'changed', False) self.posBox.editingFinished.connect(lambda: self.posCheck(self.posBox.text())) self.posBox.textChanged.connect(lambda: self.editTextChanged(self.posBox)) setattr(self.velBox, 'changed', False) self.velBox.editingFinished.connect(lambda: self.velCheck(self.velBox.text())) self.velBox.textChanged.connect(lambda: self.editTextChanged(self.velBox)) setattr(self.accelBox, 'changed', False) self.accelBox.editingFinished.connect(lambda: self.accelCheck(self.accelBox.text())) self.accelBox.textChanged.connect(lambda: self.editTextChanged(self.accelBox)) setattr(self.altBox, 'changed', False) self.altBox.editingFinished.connect(lambda: self.altCheck(self.altBox.text())) self.altBox.textChanged.connect(lambda: self.editTextChanged(self.altBox)) setattr(self.gainInput, 'changed', False) self.gainInput.editingFinished.connect(lambda: self.gainCheck(self.gainInput.text())) self.gainInput.textChanged.connect(lambda: self.editTextChanged(self.gainInput)) setattr(self.frameRateInput, 'changed', False) self.frameRateInput.editingFinished.connect(lambda: self.frameRateCheck(self.frameRateInput.text())) self.frameRateInput.textChanged.connect(lambda: self.editTextChanged(self.frameRateInput))","title":"Actions"},{"location":"documentation/#channels","text":"Connects to the different channels using kPyQt. kPyQt documentation can be found here on Keck's website. The different types are RBV (read back value), VAL (position value), VELO (velocity), ACCL (acceleration), MOVN (returns moving status), SPMG (returns one of these values: Stop, Pause, Move, Go). Writing a position value must be done to the .VAL, while reading back it's position is done through .RBV. Note: These channels are to connect to the emulator, and will need to be replaced once the real stages get setup. # Channel creation for the emulator self.posChan = kPyQt.caFactory(\"wndsim:ln:m1.RBV\", kPyQt.Channel.caFloat) self.posWritingChan = kPyQt.caFactory(\"wndsim:ln:m1.VAL\", kPyQt.Channel.caFloat) self.posMovingChan = kPyQt.caFactory(\"wndsim:ln:m1.MOVN\", kPyQt.Channel.caFloat) self.velChan = kPyQt.caFactory(\"wndsim:ln:m1.VELO\", kPyQt.Channel.caFloat) self.accelChan = kPyQt.caFactory(\"wndsim:ln:m1.ACCL\", kPyQt.Channel.caFloat) self.altChan = kPyQt.caFactory(\"altsim:ln:m1.RBV\", kPyQt.Channel.caFloat) self.altWritingChan = kPyQt.caFactory(\"altsim:ln:m1.VAL\", kPyQt.Channel.caFloat) self.altMovingChan = kPyQt.caFactory(\"altsim:ln:m1.MOVN\", kPyQt.Channel.caFloat) self.windStopChan = kPyQt.caFactory(\"wndsim:ln:m1.SPMG\", kPyQt.Channel.caFloat) self.altStopChan = kPyQt.caFactory(\"altsim:ln:m1.SPMG\", kPyQt.Channel.caFloat)","title":"Channels"},{"location":"documentation/#ao-keywords","text":"These are the keywords for the AO wavefront sensor and loop control. Callbacks are intialized during the INIT state. Note: These keywords might have to be changed once the AO system is configured for the new RTC. service = 'ao1' ao1 = ktl.cache(service) # ----------------------------------------------------------------------------------------- # A label attached to an KTL string keyword dt_key = 'dtlp' self.dt_keyword = kPyQt.kFactory(ao1[dt_key]) dm_key = 'dmlp' self.dm_keyword = kPyQt.kFactory(ao1[dm_key]) fr_key = 'wsfrrt' # Alternate keyword for frame rate for now (framerate keyword is not configured for the new RTC). Actual keyword is o1fps self.frameRate_keyword = kPyQt.kFactory(ao1[fr_key]) # gain_key = 'dtgain' # Fake keyword for gain for now (gain keyword is not configured for the new RTC). Actual keyword is o1wgs self.gain_keyword = kPyQt.caFactory('k1:ao:wc:dt:sv:gain', kPyQt.Channel.caFloat)","title":"AO Keywords"},{"location":"documentation/#toggle-visual","text":"Note: PToggle is a separate python file that was imported at the top of the code. The toggle code can be found here. Below is the section that implements PToggle to create a toggle button for the two translation stage's connection status. # ------ Translation stages' toggles -------------------------------------------- self.TS1 = PToggle(handle_color=Qt.red, checked_color=Qt.green) TS1lay = QVBoxLayout() TS1lay.addWidget(self.TS1) self.TS1tog.setLayout(TS1lay) self.TS1.setCheckState(Qt.Unchecked) self.TS2 = PToggle(handle_color=Qt.red, checked_color=Qt.green) TS2lay = QVBoxLayout() TS2lay.addWidget(self.TS2) self.TS2tog.setLayout(TS2lay) self.TS2.setCheckState(Qt.Unchecked)","title":"Toggle Visual"},{"location":"documentation/#state-machine-support","text":"Code that connects some functions necessary to transition between states in the state machine. self.setupTelSIMButtonWasPressed = False self.setupTelSIMButton.clicked.connect(self.setupTelSIMButtonPressed) self.closeTelSIMButtonWasPressed = False self.closeTelSIMButton.clicked.connect(self.closeTelSIMButtonPressed) self.startButtonWasPressed = False self.startButton.clicked.connect(self.startButtonPressed) self.stopButtonWasPressed = False self.stopButton.clicked.connect(self.stopButtonPressed) self.stateTimeout = QTimer() self.stateTimeout.setSingleShot(True) self.stateMachineTimer = QTimer() self.stateMachineTimer.timeout.connect(self.stateMachine) self.stateMachineTimer.start(75) self.state = TelSimStates.INIT","title":"State machine support"},{"location":"documentation/#functions-to-trigger-states","text":"Creation of the actual functions connected to the buttons (start, stop, setupTelSIM, closeTelSIM). def setupTelSIMButtonPressed(self): \"\"\" Trigger the state machine with a button press. :return: \"\"\" self.setupTelSIMButtonWasPressed = True def closeTelSIMButtonPressed(self): \"\"\" Trigger the state machine with a button press. :return: \"\"\" self.closeTelSIMButtonWasPressed = True def startButtonPressed(self): \"\"\" Trigger MOVE_ALT stage with a button press. :return: \"\"\" self.startButtonWasPressed = True def stopButtonPressed(self): \"\"\" Trigger MOVE_ALT stage with a button press. :return: \"\"\" self.stopButtonWasPressed = True","title":"Functions to trigger states"},{"location":"documentation/#state-machine","text":"Function that starts the state machine. def stateMachine(self): \"\"\" State machine processing. :return: \"\"\" self.statusbar.showMessage(f'STATE: {self.state.name}')","title":"State Machine"},{"location":"documentation/#state-init","text":"The INIT state runs all the callbacks to the channels and keywords. Having a separate state that does this ensures that the callbacks only happen once when the program is first opened. # ----- STATE 0 ------------------------------------------------ if self.state == TelSimStates.INIT: # Connects to the channels to read and display the values self.posChan.floatCallback.connect(self.posBoxSetText) self.posChan.runCallbacks() self.velChan.floatCallback.connect(self.velBoxSetText) self.velChan.runCallbacks() self.accelChan.floatCallback.connect(self.accelBoxSetText) self.accelChan.runCallbacks() self.altChan.floatCallback.connect(self.altBoxSetText) self.altChan.runCallbacks() self.dt_keyword.stringCallback.connect(self.loopController) self.dt_keyword.primeCallback() self.dm_keyword.stringCallback.connect(self.loopController) self.dm_keyword.primeCallback() self.frameRate_keyword.stringCallback.connect(self.frBoxSetText) self.frameRate_keyword.primeCallback() self.gain_keyword.floatCallback.connect(self.gainBoxSetText) self.gain_keyword.runCallbacks() self.state = TelSimStates.OFF return","title":"State: INIT"},{"location":"documentation/#state-off","text":"The OFF state has everything disabled except for the setupTelSIM button. Transitions to ON state if setupTelSIM button was pressed. # ----- STATE 1 ------------------------------------------------ elif self.state == TelSimStates.OFF: # Update GUI widgets for the OFF state self.startButton.setVisible(True) self.startButton.setEnabled(False) self.stopButton.setVisible(False) self.setupTelSIMButton.setEnabled(True) self.setupTelSIMButton.setVisible(True) self.closeTelSIMButton.setEnabled(False) self.closeTelSIMButton.setVisible(False) for i in self.controls: i.setEnabled(False) # Disable the widgets # If setup is pressed, advance to IDLE if self.setupTelSIMButtonWasPressed: self.setupTelSIMButtonWasPressed = False # Advance the state machine self.state = TelSimStates.IDLE return return","title":"State: OFF"},{"location":"documentation/#state-on","text":"The ON state connects the callbacks to start displaying the constant refreshing of the pos/vel/accel/alt values. Note: This had to be separated from the IDLE state because .runCallbacks() only needed to be called once upon starting up. Otherwise, the input boxes would always refresh and make it difficult for the user to edit. # ----- STATE 2 ----------------------------------------- elif self.state == TelSimStates.IDLE: # Update GUI widgets visibility self.startstopBox.setEnabled(True) self.startButton.setVisible(True) self.startButton.setEnabled(True) self.stopButton.setVisible(False) self.stopButton.setEnabled(False) self.setupTelSIMButton.setEnabled(False) self.setupTelSIMButton.setVisible(False) self.closeTelSIMButton.setEnabled(True) self.closeTelSIMButton.setVisible(True) self.LCDnumbers.display(\"0.00\") for i in self.controls: i.setEnabled(True) # Enable the widgets if self.startButtonWasPressed: self.startButtonWasPressed = False self.state = TelSimStates.MOVE_ALT return if self.closeTelSIMButtonWasPressed: self.closeTelSIMButtonWasPressed = False self.state = TelSimStates.CLEANUP return return","title":"State: ON"},{"location":"documentation/#state-idle","text":"The IDLE state enables all of the input widgets and waits for the user to hit the Start button or the closeTelSIM button and changes the state accordingly. # ----- STATE 3 ----------------------------------------- elif self.state == TelSimStates.MOVE_ALT: self.finalPos = self.posBox.text() self.finalAlt = self.altBox.text() self.initialPos = float(self.posChan.read()) self.secondsToMove = abs(float(self.initialPos) - float(self.finalPos)) / float( self.velBox.text()) # Note: self.velBox.text() is only assigned after being validated self.LCDnumbers.display(f\"{self.secondsToMove:0.2f}\") self.initialAlt = float(self.altChan.read()) if showDialog(\"Are you sure you want to START?\", yes=True, cancel=True): for i in self.controls: i.setEnabled(False) # Disable the widgets self.startButton.setVisible(False) self.startButton.setEnabled(False) self.stopButton.setVisible(True) self.stopButton.setEnabled(True) self.altStopChan.write(MOVE) self.altWrite(self.altBox.text()) self.altBox.changed = False self.stateTimeout.start(TIMEOUT_MS) self.state = TelSimStates.AWAIT_ALT return else: self.state = TelSimStates.IDLE return","title":"State: IDLE"},{"location":"documentation/#state-move_alt","text":"The MOVE_ALT state does a rough calculation of amount of time to move the wind TS (the timer is only used for the wind TS, not the alt TS. The timer and the wind TS doesn't actually start running until the alt TS has finished moving) and stores that in self.secondsToMove . It also uses the showDialog function (shown in the Details section) to ask the user to verify the start. Once verified, it will write '3' to the .SPMG channel (3 is equal to 'MOVE', in case it's currently stopped) before writing the value in the altbox to the .VAL channel. Transition to the AWAIT_ALT state is automatic once these values have been written. # ----- STATE 3 ----------------------------------------- elif self.state == TelSimStates.MOVE_ALT: self.finalPos = self.posBox.text() self.finalAlt = self.altBox.text() self.initialPos = float(self.posChan.read()) self.secondsToMove = abs(float(self.initialPos) - float(self.finalPos)) / float(self.velBox.text()) print(self.secondsToMove) self.LCDnumbers.display(f\"{self.secondsToMove:0.2f}\") self.initialAlt = float(self.altChan.read()) if showDialog(\"Are you sure you want to START?\", yes=True, cancel=True): for i in self.controls: i.setEnabled(False) # Disable the widgets self.startButton.setVisible(False) self.startButton.setEnabled(False) self.stopButton.setVisible(True) self.stopButton.setEnabled(True) print(\"altBox.text: \" + self.altBox.text()) # if self.altStopChan.read() == \"0\": self.altStopChan.write(\"3\") self.altWrite(self.altBox.text()) self.altBox.changed = False self.state = TelSimStates.AWAIT_ALT return else: self.state = TelSimStates.IDLE return","title":"State: MOVE_ALT"},{"location":"documentation/#state-await_alt","text":"Waits for the alt TS to get to its destination. Once it reaches its destination, transitions to the MOVE_WIND state. If Stop button was pressed, transitions to STOPPED state. # ----- STATE 4 ----------------------------------------- elif self.state == TelSimStates.AWAIT_ALT: if math.isclose(float(self.altChan.read()), float(self.finalAlt), abs_tol=0.05): self.stateTimeout.stop() self.stateTimeout.start(TIMEOUT_MS) self.state = TelSimStates.MOVE_WIND return if self.stopButtonWasPressed: self.stateTimeout.stop() self.stopButtonWasPressed = False self.state = TelSimStates.STOPPED return if not self.stateTimeout.isActive(): raise TimeoutError(\"Alt TS took more than 45 seconds to move\") return return","title":"State: AWAIT_ALT"},{"location":"documentation/#state-move_wind","text":"Acts similarly to the MOVE_ALT state. Also starts the timer with the self.secondsToMove value calculated in the MOVE_ALT state. Transitions to AWAIT_WIND state automatically. # ----- STATE 5 ----------------------------------------- elif self.state == TelSimStates.MOVE_WIND: self.posBox.changed = False self.velBox.changed = False self.accelBox.changed = False self.windStopChan.write(MOVE) self.accelWrite(self.accelBox.text()) self.velWrite(self.velBox.text()) self.posWrite(self.posBox.text()) self.countdownTimer.start(int(self.secondsToMove) * 1000) self.stateTimeout.start(TIMEOUT_MS) self.state = TelSimStates.AWAIT_WIND return","title":"State: MOVE_WIND"},{"location":"documentation/#state-await_wind","text":"Acts similarly to the AWAIT_ALT state. Once the wind TS reaches its destination, transitions to the IDLE state. # ----- STATE 6 ----------------------------------------- elif self.state == TelSimStates.AWAIT_WIND: self.timeLeft = self.countdownTimer.remainingTime() / 1000 self.LCDnumbers.display(f\"{self.timeLeft:0.2f}\") if math.isclose(float(self.posChan.read()), float(self.finalPos), abs_tol=0.05): self.stateTimeout.stop() self.state = TelSimStates.IDLE return if self.stopButtonWasPressed: self.stopButtonWasPressed = False self.stateTimeout.stop() self.state = TelSimStates.STOPPED return if not self.stateTimeout.isActive(): raise TimeoutError(\"Wind TS took more than 45 seconds to move\") return return","title":"State: AWAIT_WIND"},{"location":"documentation/#state-stopped","text":"Writes '0' to the two .SPMG channels ('0' is equal to 'Stop') and stops the timer. Automatically transitions to IDLE state. # ----- STATE 7 ----------------------------------------- elif self.state == TelSimStates.STOPPED: self.windStopChan.write(STOP) self.altStopChan.write(STOP) self.countdownTimer.stop() self.state = TelSimStates.IDLE return","title":"State: STOPPED"},{"location":"documentation/#state-cleanup","text":"Enables/disables widgets accordingly. Sends the two TS to their 'home' position. Automatically transitions to AWAIT_CLEANUP state. # ----- STATE 8 ----------------------------------------- elif self.state == TelSimStates.CLEANUP: self.closeTelSIMButton.setVisible(False) self.closeTelSIMButton.setEnabled(False) self.setupTelSIMButton.setVisible(True) self.setupTelSIMButton.setEnabled(False) self.startstopBox.setEnabled(False) for i in self.controls: i.setEnabled(False) self.windStopChan.write(MOVE) self.altStopChan.write(MOVE) self.posWrite(WIND_POS_HOME) self.velWrite(VEL_HOME) self.accelWrite(ACCEL_HOME) self.altWrite(ALT_POS_HOME) time.sleep(2) self.stateTimeout.start(TIMEOUT_MS) self.state = TelSimStates.AWAIT_CLEANUP return","title":"State: CLEANUP"},{"location":"documentation/#state-await_cleanup","text":"Waits for the two TS to get to their 'home' position before transitioning to OFF state. # ----- STATE 9 ----------------------------------------- elif self.state == TelSimStates.AWAIT_CLEANUP: if int(self.altMovingChan.read()) == 0: if int(self.posMovingChan.read()) == 0: if math.isclose(float(self.accelChan.read()), 0.2, abs_tol=0.2): if math.isclose(float(self.velChan.read()), 2.1, abs_tol=0.2): self.state = TelSimStates.OFF return if not self.stateTimeout.isActive(): raise TimeoutError(\"Cleanup took more than 45 seconds\") return return","title":"State: AWAIT_CLEANUP"},{"location":"documentation/#color-changing","text":"","title":"Color changing"},{"location":"documentation/#edittextchanged-and-editfinished","text":"These functions are responsible for changing the background color to red while the user is inputting a value, and changing it back once they're finished. # ------------------------------------------------------- def editTextChanged(self, edit): '''Qt signal that something was typed in the edit field''' edit.changed = True edit.setStyleSheet('background-color: red') # -------------------------------------------------------- def editFinished(self, edit): '''Qt signal that the edit field lost focus when editing, revert the value''' if edit.changed: edit.setText(edit.undoText) edit.changed = False edit.setStyleSheet(self.editStyleSheet)","title":"editTextChanged and editFinished"},{"location":"documentation/#receiving-signals-from-stage","text":"These functions use the attribute 'changed' (that was created in the Setup UI section) to prevent changing the color to red if it's receiving signals from the stage. That way, it'll only change to red if the user is inputting changes. def posBoxSetText(self, val): if not self.posBox.changed: self.posBox.setStyleSheet(\"\") self.posBox.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.posBox.setText(f\"{val:0.2f}\") self.posBox.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def velBoxSetText(self, val): if not self.velBox.changed: self.velBox.setStyleSheet(\"\") self.velBox.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.velBox.setText(f\"{val:0.2f}\") self.velBox.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def accelBoxSetText(self, val): if not self.accelBox.changed: self.accelBox.setStyleSheet(\"\") self.accelBox.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.accelBox.setText(f\"{val:0.2f}\") self.accelBox.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def altBoxSetText(self, val): if not self.altBox.changed: self.altBox.setStyleSheet(\"\") self.altBox.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.altBox.setText(f\"{val:0.1f}\") self.altBox.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def frBoxSetText(self, val): if not self.frameRateInput.changed: self.frameRateInput.setStyleSheet(\"\") self.frameRateInput.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.frameRateInput.setText(f\"{val}\") self.frameRateInput.blockSignals(False) # Turn on signals to the edit, a human is not editing it! def gainBoxSetText(self, val): if not self.gainInput.changed: self.gainInput.setStyleSheet(\"\") self.gainInput.blockSignals(True) # Turn off signals to the edit, a human is not editing it! self.gainInput.setText(f\"{val:0.2f}\") self.gainInput.blockSignals(False) # Turn on signals to the edit, a human is not editing it!","title":"Receiving signals from stage"},{"location":"documentation/#input-verification-and-writing","text":"","title":"Input Verification and Writing"},{"location":"documentation/#validators","text":"These functions make sure that the value entered in the field is within bounds. If the user is finished editing (clicks away), then the showDialog function is used to give an error message. # --- Corrects pos/vel/accel/alt values after edited? -------------------- def posCheck(self, msg): ''' Makes sure the value entered in the field is within bounds. If not, will show error message. Also assigns self.finalPos used later for calculating time it will take to move :param msg: Value entered in posBox text box ''' self.posBox.validator = QDoubleValidator(WIND_POS_MIN, WIND_POS_MAX, 2, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.posBox.validator, str(msg), 0)[ 0] != 2: # When this object is != 2, that means that it's not an acceptable input self.posBox.setText(f\"{float(self.posChan.read()):0.2f}\") showDialog(\"Position must be a float between -40.00 and 40.00\") def velCheck(self, msg): self.velBox.validator = QDoubleValidator(VEL_MIN, VEL_MAX, 2, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.velBox.validator, str(msg), 0)[0] != 2: self.velBox.setText(f\"{float(self.velChan.read()):0.2f}\") showDialog(\"Velocity must be a float between 2.00 and 80.00\") else: # Ensures self.velVal assignment ONLY if the input passes the validator self.velVal = msg def accelCheck(self, msg): self.accelBox.validator = QDoubleValidator(ACCEL_MIN, ACCEL_MAX, 2, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.accelBox.validator, str(msg), 0)[0] != 2: self.accelBox.setText(f\"{float(self.accelChan.read()):0.2f}\") showDialog(\"Acceleration must be a float between 0.00 and 10.00\") def gainCheck(self, msg): self.gainInput.validator = QDoubleValidator(GAIN_MIN, GAIN_MAX, 2, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.gainInput.validator, str(msg), 0)[0] != 2: self.gainInput.setText(f\"{float(self.gain_keyword.read()):0.2f}\") showDialog(\"Gain must be between 0 and 1\") else: self.gain_keyword.write(msg) self.gainInput.changed = False def altCheck(self, msg): self.altBox.validator = QDoubleValidator(ALT_MIN, ALT_MAX, 1, notation=QDoubleValidator.StandardNotation) if QDoubleValidator.validate(self.altBox.validator, str(msg), 0)[0] != 2: self.altBox.setText(f\"{float(self.altChan.read()):0.1f}\") showDialog(\"Altitude must be between 5.0 and 12.0\") def frameRateCheck(self, msg): if self.unbin.isChecked() == True: self.frameRateInput.validator = QIntValidator(FRAMERATE_MIN, UNBINNED_MODE, self) else: self.frameRateInput.validator = QIntValidator(FRAMERATE_MIN, BINNED_MODE, self) if QIntValidator.validate(self.frameRateInput.validator, str(msg), 0)[0] != 2: self.frameRateInput.setText(\"1\") showDialog(\"Frame rate must be integer between 1-2000 when in unbinned mode and \" \"1-3600 when in binned mode; automatically reset frame to 1\") else: self.frameRate_keyword.write(msg) self.frameRateInput.changed = False","title":"Validators"},{"location":"documentation/#writing-to-channel","text":"These functions write the value passed through to the appropriate channel. The wait=False in the position and altitude writing channels are necessary to allow the user to stop the motion while the stages are moving to their destination. # ---- Writes the pos/vel/accel/alt to the emulator -------------------------------------------- def posWrite(self, msg): ''' Writes the value to the writing channel :param msg: Position value ''' f = float(msg) self.posWritingChan.write(f, wait=False) def velWrite(self, msg): f = float(msg) self.velChan.write(f) def accelWrite(self, msg): f = float(msg) self.accelChan.write(f) def altWrite(self, msg): f = float(msg) self.altWritingChan.write(f, wait=False)","title":"Writing to channel"},{"location":"documentation/#loop-control","text":"These functions are responsible for displaying the correct radio button for loop control, and sending the write signals when each button is pressed. def loopController(self): \"\"\" Selects the correct radio button based on status of dmlp and dtlp keywords \"\"\" if self.dt_keyword.read() == \"CLOSE\" and self.dm_keyword.read() == \"CLOSE\": self.closedLoop.setChecked(True) else: self.openLoop.setChecked(True) def openLoopButton_clicked(self): \"\"\" Turns loop off (opens loop) \"\"\" if self.dt_keyword.read() == \"CLOSE\" or self.dm_keyword.read() == \"CLOSE\": self.dm_keyword.write(\"OPEN\") time.sleep(0.5) self.dt_keyword.write(\"OPEN\") def closeLoopButton_clicked(self): \"\"\" Turns loop on (closes loop) \"\"\" if self.dt_keyword.read() == \"OPEN\" or self.dm_keyword.read() == \"OPEN\": self.dt_keyword.write(\"CLOSE\") time.sleep(0.5) self.dm_keyword.write(\"CLOSE\")","title":"Loop Control"},{"location":"documentation/#main-function","text":"This is the standard startup main function for all kPyQt GUIs. if __name__ == '__main__': # ------------------------------------------------------------------------- # Commandline arguments parser = argparse.ArgumentParser(description='Turbulence Simulator GUI') parser.add_argument('-d', '--debug', help='Enable debugging output', action='store_true') args = parser.parse_args() # Get the debug argument first, as it drives our logging choices if args.debug: debug = True # ------------------------------------------------------------------------- # Set up the base logger all threads will use, once we know the debug flag coloredlogs.DEFAULT_LOG_FORMAT = '%(asctime)s [%(levelname)s] %(message)s' coloredlogs.DEFAULT_DATE_FORMAT = '%Y-%m-%d %H:%M:%S.%f' if debug: coloredlogs.install(level='DEBUG') else: coloredlogs.install(level='INFO') log = logging.getLogger('') # Disable the debug logging from Qt logging.getLogger('PyQt5').setLevel(logging.WARNING) application = QtWidgets.QApplication(sys.argv) mainwin = TurbulenceSimulatorGUIMain() mainwin.setupUI() # mainwin.setMinimumSize(0, 0) # mainwin.resize(10,10) mainwin.show() # Run the Qt application status = kPyQt.run(application) sys.exit(status)","title":"Main function"},{"location":"documentation/#toggle-code","text":"from PyQt5.QtCore import ( Qt, QSize, QPoint, QPointF, QRectF, QEasingCurve, QPropertyAnimation, QSequentialAnimationGroup, pyqtSlot, pyqtProperty) from PyQt5.QtWidgets import QCheckBox from PyQt5.QtGui import QColor, QBrush, QPaintEvent, QPen, QPainter from PyQt5.QtCore import pyqtSlot as Slot, pyqtProperty as Property class PToggle(QCheckBox): \"\"\"Derived from qtwidgets.Toggle at https://github.com/pythonguis/python-qtwidgets/blob/master/qtwidgets/toggle/toggle.py\"\"\" _transparent_pen = QPen(Qt.transparent) _light_grey_pen = QPen(Qt.lightGray) _dark_gray_pen = QPen(Qt.darkGray) def __init__(self, parent=None, bar_color=Qt.gray, checked_color=\"#00B0FF\", handle_color=Qt.white, ): super().__init__(parent) # Save our properties on the object via self, so we can access them later # in the paintEvent. self._bar_brush = QBrush(bar_color) self._bar_checked_brush = QBrush(QColor(checked_color).lighter()) self._bar_partially_checked_brush = QBrush(Qt.gray) self._handle_brush = QBrush(handle_color) self._handle_checked_brush = QBrush(QColor(checked_color)) self._handle_partially_checked_brush = QBrush(Qt.gray) self._handle_disabled_brush = QBrush(Qt.darkGray) # Setup the rest of the widget. self.setContentsMargins(8, 0, 8, 0) self._handle_position = 0 self.stateChanged.connect(self.handle_state_change) def sizeHint(self): return QSize(58, 45) def hitButton(self, pos: QPoint): return self.contentsRect().contains(pos) def paintEvent(self, e: QPaintEvent): contRect = self.contentsRect() handleRadius = round(0.24 * contRect.height()) p = QPainter(self) p.setRenderHint(QPainter.Antialiasing) p.setPen(self._transparent_pen) barRect = QRectF( 0, 0, contRect.width() - handleRadius, 0.40 * contRect.height() ) barRect.moveCenter(contRect.center()) rounding = barRect.height() / 2 # the handle will move along this line trailLength = contRect.width() - 2 * handleRadius xPos = contRect.x() + handleRadius + trailLength * self._handle_position if self.checkState() == Qt.PartiallyChecked: p.setBrush(self._bar_partially_checked_brush) p.drawRoundedRect(barRect, rounding, rounding) # Don't draw the handle if partially checked! elif self.checkState() == Qt.Checked: p.setBrush(self._bar_checked_brush) p.drawRoundedRect(barRect, rounding, rounding) if self.isEnabled(): p.setBrush(self._handle_checked_brush) else: p.setBrush(self._handle_disabled_brush) p.drawEllipse(QPointF(xPos, barRect.center().y()), handleRadius, handleRadius) # Unchecked else: p.setBrush(self._bar_brush) p.drawRoundedRect(barRect, rounding, rounding) p.setPen(self._light_grey_pen) if self.isEnabled(): p.setBrush(self._handle_brush) else: p.setBrush(self._handle_disabled_brush) p.drawEllipse(QPointF(xPos, barRect.center().y()), handleRadius, handleRadius) p.end() @Slot(int) def handle_state_change(self, value): self._handle_position = 1 if value else 0 @Property(float) def handle_position(self): return self._handle_position @handle_position.setter def handle_position(self, pos): \"\"\"change the property we need to trigger QWidget.update() method, either by: 1- calling it here [ what we're doing ]. 2- connecting the QPropertyAnimation.valueChanged() signal to it. \"\"\" self._handle_position = pos self.update() @Property(float) def pulse_radius(self): return self._pulse_radius @pulse_radius.setter def pulse_radius(self, pos): self._pulse_radius = pos self.update() class PAnimatedToggle(PToggle): _transparent_pen = QPen(Qt.transparent) _light_grey_pen = QPen(Qt.lightGray) def __init__(self, *args, pulse_unchecked_color=\"#44999999\", pulse_checked_color=\"#4400B0EE\", **kwargs): self._pulse_radius = 0 super().__init__(*args, **kwargs) self.animation = QPropertyAnimation(self, b\"handle_position\", self) self.animation.setEasingCurve(QEasingCurve.InOutCubic) self.animation.setDuration(200) # time in ms self.pulse_anim = QPropertyAnimation(self, b\"pulse_radius\", self) self.pulse_anim.setDuration(350) # time in ms self.pulse_anim.setStartValue(10) self.pulse_anim.setEndValue(20) self.animations_group = QSequentialAnimationGroup() self.animations_group.addAnimation(self.animation) self.animations_group.addAnimation(self.pulse_anim) self._pulse_unchecked_animation = QBrush(QColor(pulse_unchecked_color)) self._pulse_checked_animation = QBrush(QColor(pulse_checked_color)) @Slot(int) def handle_state_change(self, value): self.animations_group.stop() if value: self.animation.setEndValue(1) else: self.animation.setEndValue(0) self.animations_group.start() def paintEvent(self, e: QPaintEvent): contRect = self.contentsRect() handleRadius = round(0.24 * contRect.height()) p = QPainter(self) p.setRenderHint(QPainter.Antialiasing) p.setPen(self._transparent_pen) barRect = QRectF( 0, 0, contRect.width() - handleRadius, 0.40 * contRect.height() ) barRect.moveCenter(contRect.center()) rounding = barRect.height() / 2 # the handle will move along this line trailLength = contRect.width() - 2 * handleRadius xPos = contRect.x() + handleRadius + trailLength * self._handle_position # Animate, unless partially checked if self.checkState() in [Qt.Checked, Qt.Unchecked]: if self.pulse_anim.state() == QPropertyAnimation.Running: p.setBrush( self._pulse_checked_animation if self.isChecked() else self._pulse_unchecked_animation) p.drawEllipse(QPointF(xPos, barRect.center().y()), self._pulse_radius, self._pulse_radius) if self.checkState() == Qt.PartiallyChecked: p.setBrush(self._bar_partially_checked_brush) p.drawRoundedRect(barRect, rounding, rounding) # Don't draw the handle if partially checked! elif self.checkState() == Qt.Checked: p.setBrush(self._bar_checked_brush) p.drawRoundedRect(barRect, rounding, rounding) if self.isEnabled(): p.setBrush(self._handle_checked_brush) else: p.setBrush(self._handle_disabled_brush) p.drawEllipse(QPointF(xPos, barRect.center().y()),handleRadius, handleRadius) else: p.setBrush(self._bar_brush) p.drawRoundedRect(barRect, rounding, rounding) p.setPen(self._light_grey_pen) if self.isEnabled(): p.setBrush(self._handle_brush) else: p.setBrush(self._handle_disabled_brush) p.drawEllipse(QPointF(xPos, barRect.center().y()),handleRadius, handleRadius) p.end()","title":"Toggle Code"}]}